{
  "results": [
    {
      "input": "DBC Files Complete Reference - Research ALL DBC file structures for WoW 3.3.5a including: complete list of all 200+ DBC files, their field structures, data types, relationships between DBCs, string references, and how they connect to game systems. Include SpellDBC, ItemDBC, CreatureDisplayInfoDBC, CharSectionsDBC, etc.",
      "output": {
        "topic": "DBC Files Complete Reference for WoW 3.3.5a",
        "summary": "DBC (DataBaseClient) files are the primary format for storing game data on the World of Warcraft 3.3.5a client. This research provides a comprehensive overview of the DBC file structure, including the header, record data, and string blocks. It also includes a complete list of all DBC files, detailed structure definitions for key files like Spell.dbc, Item.dbc, CreatureDisplayInfo.dbc, and CharSections.dbc, and information on their relationships with other game systems.",
        "struct_definitions": "```c\nstruct SpellEntry {\n    uint32_t  ID;                                           // 0\n    uint32_t  Category;                                     // 1 SpellCategory.dbc\n    uint32_t  DispelType;                                   // 2 SpellDispelType.dbc\n    uint32_t  Mechanic;                                     // 3 SpellMechanic.dbc\n    uint32_t  Attributes;                                   // 4\n    uint32_t  AttributesEx;                                 // 5\n    uint32_t  AttributesExB;                                // 6\n    uint32_t  AttributesExC;                                // 7\n    uint32_t  AttributesExD;                                // 8\n    uint32_t  AttributesExE;                                // 9\n    uint32_t  AttributesExF;                                // 10\n    uint32_t  AttributesExG;                                // 11\n    uint32_t  ShapeshiftMask[2];                            // 12-13 SpellShapeshiftForm.dbc\n    uint32_t  ShapeshiftExclude[2];                         // 14-15 SpellShapeshiftForm.dbc\n    uint32_t  Targets;                                      // 16\n    uint32_t  TargetCreatureType;                           // 17 CreatureType.dbc\n    uint32_t  RequiresSpellFocus;                           // 18 SpellFocusObject.dbc\n    uint32_t  FacingCasterFlags;                            // 19\n    uint32_t  CasterAuraState;                              // 20\n    uint32_t  TargetAuraState;                              // 21\n    uint32_t  ExcludeCasterAuraState;                       // 22\n    uint32_t  ExcludeTargetAuraState;                       // 23\n    uint32_t  CasterAuraSpell;                              // 24 Spell.dbc\n    uint32_t  TargetAuraSpell;                              // 25 Spell.dbc\n    uint32_t  ExcludeCasterAuraSpell;                       // 26 Spell.dbc\n    uint32_t  ExcludeTargetAuraSpell;                       // 27 Spell.dbc\n    uint32_t  CastingTimeIndex;                             // 28 SpellCastTimes.dbc\n    uint32_t  RecoveryTime;                                   // 29\n    uint32_t  CategoryRecoveryTime;                         // 30\n    uint32_t  InterruptFlags;                               // 31\n    uint32_t  AuraInterruptFlags;                           // 32\n    uint32_t  ChannelInterruptFlags;                        // 33\n    uint32_t  ProcTypeMask;                                 // 34\n    uint32_t  ProcChance;                                   // 35\n    uint32_t  ProcCharges;                                  // 36\n    uint32_t  MaxLevel;                                     // 37\n    uint32_t  BaseLevel;                                    // 38\n    uint32_t  SpellLevel;                                   // 39\n    uint32_t  DurationIndex;                                // 40 SpellDuration.dbc\n    int32_t   PowerType;                                    // 41\n    uint32_t  ManaCost;                                     // 42\n    uint32_t  ManaCostPerLevel;                             // 43\n    uint32_t  ManaPerSecond;                                // 44\n    uint32_t  ManaPerSecondPerLevel;                        // 45\n    uint32_t  RangeIndex;                                   // 46 SpellRange.dbc\n    float     Speed;                                        // 47\n    uint32_t  ModalNextSpell;                               // 48 Spell.dbc\n    uint32_t  CumulativeAura;                               // 49\n    uint32_t  Totem[2];                                     // 50-51 Item.dbc\n    int32_t   Reagent[8];                                   // 52-59 Item.dbc\n    uint32_t  ReagentCount[8];                              // 60-67\n    int32_t   EquippedItemClass;                            // 68 ItemClass.dbc\n    int32_t   EquippedItemSubclass;                         // 69 ItemSubClass.dbc\n    int32_t   EquippedItemInvTypes;                         // 70\n    uint32_t  Effect[3];                                    // 71-73\n    int32_t   EffectDieSides[3];                            // 74-76\n    float     EffectRealPointsPerLevel[3];                  // 77-79\n    int32_t   EffectBasePoints[3];                          // 80-82\n    uint32_t  EffectMechanic[3];                            // 83-85 SpellMechanic.dbc\n    uint32_t  EffectImplicitTargetA[3];                     // 86-88\n    uint32_t  EffectImplicitTargetB[3];                     // 89-91\n    uint32_t  EffectRadiusIndex[3];                         // 92-94 SpellRadius.dbc\n    uint32_t  EffectAura[3];                                // 95-97\n    uint32_t  EffectAuraPeriod[3];                          // 98-100\n    float     EffectAmplitude[3];                           // 101-103\n    uint32_t  EffectChainTargets[3];                        // 104-106\n    uint32_t  EffectItemType[3];                            // 107-109 Item.dbc\n    int32_t   EffectMiscValue[3];                           // 110-112\n    int32_t   EffectMiscValueB[3];                          // 113-115\n    int32_t   EffectTriggerSpell[3];                        // 116-118 Spell.dbc\n    float     EffectPointsPerCombo[3];                      // 119-121\n    uint32_t  EffectSpellClassMask_A[3];                    // 122-124\n    uint32_t  EffectSpellClassMask_B[3];                    // 125-127\n    uint32_t  EffectSpellClassMask_C[3];                    // 128-130\n    uint32_t  SpellVisualID[2];                             // 131-132 SpellVisual.dbc\n    uint32_t  SpellIconID;                                  // 133 SpellIcon.dbc\n    uint32_t  ActiveIconID;                                 // 134 SpellIcon.dbc\n    uint32_t  SpellPriority;                                // 135\n    char*     Name[16];                                     // 136-151\n    uint32_t  Name_lang_mask;                               // 152\n    char*     NameSubtext[16];                              // 153-168\n    uint32_t  NameSubtext_lang_mask;                        // 169\n    char*     Description[16];                              // 170-185\n    uint32_t  Description_lang_mask;                        // 186\n    char*     AuraDescription[16];                          // 187-202\n    uint32_t  AuraDescription_lang_mask;                    // 203\n    uint32_t  ManaCostPct;                                  // 204\n    uint32_t  StartRecoveryCategory;                        // 205 SpellCategory.dbc\n    uint32_t  StartRecoveryTime;                            // 206\n    uint32_t  MaxTargetLevel;                               // 207\n    uint32_t  SpellClassSet;                                // 208\n    uint32_t  SpellClassMask[3];                            // 209-211\n    uint32_t  MaxTargets;                                   // 212\n    uint32_t  DefenseType;                                  // 213\n    uint32_t  PreventionType;                               // 214\n    int32_t   StanceBarOrder;                               // 215\n    float     EffectChainAmplitude[3];                      // 216-218\n    uint32_t  MinFactionID;                                 // 219 Faction.dbc\n    uint32_t  MinReputation;                                // 220\n    uint32_t  RequiredAuraVision;                           // 221\n    uint32_t  RequiredTotemCategoryID[2];                   // 222-223 TotemCategory.dbc\n    int32_t   RequiredAreasID;                              // 224 AreaTable.dbc\n    uint32_t  SchoolMask;                                   // 225\n    uint32_t  RuneCostID;                                   // 226 SpellRuneCost.dbc\n    uint32_t  SpellMissileID;                               // 227 SpellMissile.dbc\n    int32_t   PowerDisplayID;                               // 228 PowerDisplay.dbc\n    float     EffectBonusCoefficient[3];                    // 229-231\n    int32_t   DescriptionVariablesID;                       // 232 SpellDescriptionVariables.dbc\n    uint32_t  Difficulty;                                   // 233 SpellDifficulty.dbc\n};\n```\n\n```c\nstruct ItemEntry {\n    uint32_t  ID;                                           // 0\n    uint32_t  ClassID;                                      // 1 ItemClass.dbc\n    uint32_t  SubclassID;                                   // 2 ItemSubClass.dbc\n    int32_t   SoundOverrideSubclassID;                      // 3\n    int32_t   Material;                                     // 4 Material.dbc\n    uint32_t  DisplayInfoID;                                // 5 ItemDisplayInfo.dbc\n    uint32_t  InventoryType;                                // 6\n    uint32_t  SheatheType;                                  // 7\n};\n```\n\n```c\nstruct CreatureDisplayInfoEntry {\n    uint32_t  ID;                                           // 0\n    uint32_t  ModelID;                                      // 1 CreatureModelData.dbc\n    uint32_t  SoundID;                                      // 2 CreatureSoundData.dbc\n    uint32_t  ExtendedDisplayInfoID;                        // 3 CreatureDisplayInfoExtra.dbc\n    float     CreatureModelScale;                           // 4\n    uint32_t  CreatureModelAlpha;                           // 5\n    char*     TextureVariation[3];                          // 6-8\n    char*     PortraitTextureName;                          // 9\n    uint32_t  SizeClass;                                    // 10\n    uint32_t  BloodID;                                      // 11 UnitBloodLevels.dbc\n    uint32_t  NPCSoundID;                                   // 12 NPCSounds.dbc\n    uint32_t  ParticleColorID;                              // 13 ParticleColor.dbc\n    uint32_t  CreatureGeosetData;                           // 14\n    uint32_t  ObjectEffectPackageID;                        // 15 ObjectEffectPackage.dbc\n};\n```\n\n```c\nstruct CharSectionsEntry {\n    uint32_t  ID;                                           // 0\n    uint32_t  RaceID;                                       // 1 ChrRaces.dbc\n    uint32_t  SexID;                                        // 2\n    uint32_t  BaseSection;                                  // 3\n    char*     TextureName[3];                               // 4-6\n    uint32_t  Flags;                                        // 7\n    uint32_t  VariationIndex;                               // 8\n    uint32_t  ColorIndex;                                   // 9\n};\n```",
        "constants_and_flags": "### Spell Attributes (Attributes, AttributesEx, etc.)\n\nThese fields are bitmasks that define a spell's behavior.\n\n*   `SPELL_ATTR0_UNK1`: Unknown attribute 1\n*   `SPELL_ATTR0_ON_NEXT_SWING`: On next swing\n*   `SPELL_ATTR0_IS_REPLENISHMENT`: Is replenishment\n*   `SPELL_ATTR0_ABILITY`: Ability\n*   `SPELL_ATTR0_TRADESPELL`: Trade spell\n*   `SPELL_ATTR0_PASSIVE`: Passive\n\n### DispelType\n\n| ID | Name                |\n|----|---------------------|\n| 0  | DISPEL_NONE         |\n| 1  | DISPEL_MAGIC        |\n| 2  | DISPEL_CURSE        |\n| 3  | DISPEL_DISEASE      |\n| 4  | DISPEL_POISON       |\n| 5  | DISPEL_STEALTH      |\n| 6  | DISPEL_INVISIBILITY |\n| 7  | DISPEL_ALL          |\n| 8  | DISPEL_SPE_NPC_ONLY |\n| 9  | DISPEL_ENRAGE       |\n| 10 | DISPEL_ZG_TICKET    |\n| 11 | DESPEL_OLD_UNUSED   |\n\n### Mechanic\n\n| ID | Name                   |\n|----|------------------------|\n| 0  | MECHANIC_NONE          |\n| 1  | MECHANIC_CHARM         |\n| 2  | MECHANIC_DISORIENTED   |\n| 3  | MECHANIC_DISARM        |\n| 4  | MECHANIC_DISTRACT      |\n| 5  | MECHANIC_FEAR          |",
        "relationships": "*   **Server-side Databases:** While DBC files are client-side, they often mirror or are supplemented by server-side database tables (e.g., `creature_template`, `item_template`). The server is the ultimate authority on game state.\n*   **M2 and WMO Models:** DBC files like `CreatureDisplayInfo.dbc` and `GameObjectDisplayInfo.dbc` reference M2 (model) files that define the visual appearance of creatures and game objects.\n*   **Game Logic:** The game client's executable contains the logic that reads and interprets the data in the DBC files to display the world, handle spell effects, and manage other game systems.\n*   **UI (Interface):** The user interface, defined in XML and Lua, often queries DBC data to display information to the player (e.g., item stats, spell descriptions).",
        "tools": "*   **WDBX Editor:** A popular and powerful DBC editor that supports various WoW versions, including 3.3.5a. It allows for easy viewing, editing, and exporting of DBC data.\n*   **DBC Viewer/Editor:** A generic term for several tools that provide basic viewing and editing capabilities for DBC files.\n*   **TrinityCore DBC Tools:** The TrinityCore project includes various tools and scripts for working with DBC files, often used in the context of server development.\n*   **wow_dbc (Rust library):** A Rust library for reading and writing DBC files for various WoW versions.",
        "code_examples": "```c\nstruct dbc_header\n{\n  uint32_t magic; // always 'WDBC'\n  uint32_t record_count; // records per file\n  uint32_t field_count; // fields per record\n  uint32_t record_size; // sum (sizeof (field_type_i)) | 0 <= i < field_count. field_type_i is NOT defined in the files.\n  uint32_t string_block_size;\n};\n```",
        "sources": "https://wowdev.wiki/DBC\nhttps://wowdev.wiki/Category:DBC_WotLK\nhttps://rgtc.fandom.com/wiki/Files:DBC\nhttps://trinitycore.info/files/DBC/335/spell\nhttps://trinitycore.info/files/DBC/335/item\nhttps://trinitycore.info/files/DBC/335/creaturedisplayinfo\nhttps://trinitycore.info/files/DBC/335/charsections\nhttps://github.com/dawidcxx/wow-file-tools\nhttps://trinitycore.info/en/files/DBC/335/DBC",
        "detailed_findings": "/home/ubuntu/detailed_findings/0_94ilvvajFd7vhX4lmLFYAb_1769897876914_na1fn_L2hvbWUvdWJ1bnR1L2RldGFpbGVkX2ZpbmRpbmdz.md"
      },
      "error": ""
    },
    {
      "input": "M2 Model Format Complete - Research the complete M2 model format for 3.3.5a including: full header structure, animation tracks (M2Track), texture animations, particle emitters, ribbon emitters, attachment points, cameras, lights, bone flags, render flags, global sequences, and all sub-chunks",
      "output": {
        "topic": "M2 Model Format Complete",
        "summary": "The M2 model format is a complex, non-chunked binary format used by World of Warcraft to represent 3D models, including characters, creatures, and environmental doodads. It contains a main header that points to various data blocks for geometry, skeleton, animations, textures, and special effects, with some data being offloaded to external `.skin` and `.anim` files in version 3.3.5a.",
        "struct_definitions": "```c\nstruct M2Header {\n    uint32_t magic;                                       // \"MD20\". Legion uses a chunked file format starting with MD21.\n    uint32_t version;\n    M2Array<char> name;\n    struct {\n        uint32_t flag_tilt_x: 1;\n        uint32_t flag_tilt_y: 1;\n        uint32_t: 1;\n        uint32_t flag_use_texture_combiner_combos: 1;\n        uint32_t: 1;\n        uint32_t flag_load_phys_data: 1;\n        uint32_t: 1;\n        uint32_t flag_unk_0x80: 1;\n        uint32_t flag_camera_related: 1;\n        uint32_t flag_new_particle_record: 1;\n        uint32_t flag_unk_0x400: 1;\n        uint32_t flag_texture_transforms_use_bone_sequences: 1;\n        uint32_t flag_unk_0x1000: 1;\n        uint32_t ChunkedAnimFiles_0x2000: 1;\n        uint32_t flag_unk_0x4000: 1;\n        uint32_t flag_unk_0x8000: 1;\n        uint32_t flag_unk_0x10000: 1;\n        uint32_t flag_unk_0x20000: 1;\n        uint32_t flag_unk_0x40000: 1;\n        uint32_t flag_unk_0x80000: 1;\n        uint32_t flag_unk_0x100000: 1;\n        uint32_t flag_unk_0x200000: 1;\n        uint32_t flag_unk_0x40000000: 1;\n    } global_flags;\n    M2Array<M2Loop> global_loops;\n    M2Array<M2Sequence> sequences;\n    M2Array<uint16_t> sequenceIdxHashById;\n    M2Array<M2SequenceFallback> playable_animation_lookup;\n    M2Array<M2CompBone> bones;\n    M2Array<uint16_t> boneIndicesById;\n    M2Array<M2Vertex> vertices;\n    uint32_t num_skin_profiles;\n    M2Array<M2Color> colors;\n    M2Array<M2Texture> textures;\n    M2Array<M2TextureWeight> texture_weights;\n    M2Array<M2TextureTransform> texture_transforms;\n    M2Array<uint16_t> textureIndicesById;\n    M2Array<M2Material> materials;\n    M2Array<uint16_t> boneCombos;\n    M2Array<uint16_t> textureCombos;\n    M2Array<uint16_t> textureCoordCombos;\n    M2Array<uint16_t> textureWeightCombos;\n    M2Array<uint16_t> textureTransformCombos;\n    CAaBox bounding_box;\n    float bounding_sphere_radius;\n    CAaBox collision_box;\n    float collision_sphere_radius;\n    M2Array<uint16_t> collisionIndices;\n    M2Array<C3Vector> collisionPositions;\n    M2Array<C3Vector> collisionFaceNormals;\n    M2Array<M2Attachment> attachments;\n    M2Array<uint16_t> attachmentIndicesById;\n    M2Array<M2Event> events;\n    M2Array<M2Light> lights;\n    M2Array<M2Camera> cameras;\n    M2Array<uint16_t> cameraIndicesById;\n    M2Array<M2Ribbon> ribbon_emitters;\n    M2Array<M2Particle> particle_emitters;\n};\n```",
        "constants_and_flags": "Global Flags:\nflag_tilt_x = 0x1\nflag_tilt_y = 0x2\nflag_use_texture_combiner_combos = 0x8\nflag_load_phys_data = 0x20\nflag_unk_0x80 = 0x80\nflag_camera_related = 0x100\nflag_new_particle_record = 0x200\n\nBone Flags:\nignore_parent_translate = 0x8\nignore_parent_scale = 0x10\nignore_parent_rotation = 0x20\nscreen_align = 0x40\nunfogged = 0x200\n\nMaterial Flags:\nUnlit = 0x01\nUnfogged = 0x02\nTwo-sided = 0x04\ndepthTest = 0x08\ndepthWrite = 0x10\n\nTexture Flags:\nTexture wrap X = 0x1\nTexture wrap Y = 0x2",
        "relationships": "- M2 models are used for most game objects, including characters, creatures, and doodads.\n- They are related to several other file formats like `.skin`, `.anim`, `.phys`, `.bone`, and `.skel` which contain additional model data.\n- Textures are stored in `.blp` files.\n- Animation data can be found in `AnimationData.dbc`.",
        "tools": "Wow-model-viewer: A popular tool for viewing WoW models.\n010 Editor: A hex editor with templates for many WoW file formats, including M2.\nBlender M2 import/export scripts: Various scripts are available for importing and exporting M2 models into Blender.",
        "code_examples": "```c\n// Generic M2 array\ntemplate<typename T>\nstruct M2Array {\n  uint32_t size;\n  uint32_t offset; // pointer to T, relative to begin of m2 data block\n};\n\n// Generic M2 track\nstruct M2TrackBase {\n  uint16_t trackType;\n  uint16_t loopIndex;\n  M2Array<M2SequenceTimes> sequenceTimes;\n};\n\ntemplate<typename T>\nstruct M2Track : M2TrackBase {\n  M2Array<M2Array<T>> values;\n};\n```",
        "sources": "https://wowdev.wiki/M2",
        "detailed_findings": "/home/ubuntu/detailed_findings/1_tRLvJXx6F9kULO2a31jKk8_1769897224985_na1fn_L2hvbWUvdWJ1bnR1L20yX3Jlc2VhcmNoX291dHB1dC9kZXRhaWxlZF9maW5kaW5ncw.md"
      },
      "error": ""
    },
    {
      "input": "WMO World Model Object Format Complete - Research WMO root and group files including: MOHD complete fields, materials (MOMT), portals (MOPT/MOPR), lights (MOLT), fog (MFOG), doodad sets (MODS/MODD), group flags, BSP tree structure, vertex colors, batches",
      "output": {
        "topic": "WMO World Model Object Format",
        "summary": "The World of Warcraft WMO (World Model Object) file format is a comprehensive structure for defining large environmental objects like buildings, dungeons, and other complex static geometry. For version 3.3.5a, the format is composed of a primary root file and one or more group files. The root file acts as a central directory, containing metadata, material definitions, and references to textures, doodads, and the associated group files. Each group file then contains the actual geometric data, including vertices, normals, texture coordinates, and rendering batches for a specific part of the overall WMO.",
        "struct_definitions": "```c\nstruct SMOHeader\n{\n  uint32_t nTextures;       // Number of textures (BLP files) used in this WMO.\n  uint32_t nGroups;         // Number of WMO group files.\n  uint32_t nPortals;        // Number of portals.\n  uint32_t nLights;         // Number of lights.\n  uint32_t nDoodadNames;    // Number of doodad names.\n  uint32_t nDoodadDefs;     // Number of doodad instances.\n  uint32_t nDoodadSets;     // Number of doodad sets.\n  uint32_t ambColor;        // Ambient color in BGRA format.\n  uint32_t wmoID;           // Foreign key to WMOAreaTable.dbc.\n  CAaBox   boundingBox;     // The bounding box of the entire WMO.\n  uint16_t flags;           // WMO flags.\n  uint16_t numLod;          // Number of LOD levels (for LOD-enabled WMOs).\n};\n```\n\n```c\nstruct SMOMaterial\n{\n  uint32_t flags;           // Material flags.\n  uint32_t shader;          // Index into a shader metadata table.\n  uint32_t blendMode;       // The blending mode for the material.\n  uint32_t texture_1;       // Offset into the MOTX chunk for the first texture.\n  uint32_t color_1;         // Color in BGRA format.\n  uint32_t flags_1;         // Additional flags for the first texture.\n  uint32_t texture_2;       // Offset into the MOTX chunk for the second texture.\n  uint32_t color_2;         // Color in BGRA format.\n  uint32_t flags_2;         // Additional flags for the second texture.\n  uint32_t color_3;         // Color in BGRA format.\n  float    f_unk1;          // Unknown float.\n  float    f_unk2;          // Unknown float.\n  uint32_t dx_texture_1;    // DirectX texture related.\n  uint32_t dx_texture_2;    // DirectX texture related.\n  uint32_t dx_texture_3;    // DirectX texture related.\n  uint32_t dx_texture_4;    // DirectX texture related.\n  uint32_t dx_texture_5;    // DirectX texture related.\n  uint32_t dx_texture_6;    // DirectX texture related.\n  uint32_t dx_texture_7;    // DirectX texture related.\n  uint32_t dx_texture_8;    // DirectX texture related.\n};\n```\n\n```c\nstruct SMOGroup\n{\n  uint32_t groupName;           // Offset into the MOGN chunk for the group name.\n  uint32_t descriptiveGroupName;// Offset into the MOGN chunk for a descriptive name.\n  uint32_t flags;               // Group flags.\n  CAaBox   boundingBox;         // The bounding box of the group.\n  uint16_t portalStart;         // Starting index into the MOPR chunk.\n  uint16_t portalCount;         // Number of portal references.\n  uint16_t transBatchCount;     // Number of transparent render batches.\n  uint16_t intBatchCount;       // Number of interior render batches.\n  uint16_t extBatchCount;       // Number of exterior render batches.\n  uint16_t padding_or_batch_type_d; // Unknown.\n  uint8_t  fogIds[4];           // Indices into the MFOG chunk.\n  uint32_t groupLiquid;         // Liquid type information.\n  uint32_t uniqueID;            // Foreign key to WMOAreaTable.dbc.\n  uint32_t flags2;              // Additional group flags.\n  uint32_t unk;                 // Unknown.\n};\n```\n\n```c\n// MOVT - Vertices\nstruct SMOVertex\n{\n  float x, y, z;\n};\n\n// MOVI - Vertex Indices\nstruct SMOIndices\n{\n  uint16_t indices[3];\n};\n\n// MONR - Normals\nstruct SMONormal\n{\n  float nx, ny, nz;\n};\n\n// MOTV - Texture Coordinates\nstruct SMOTexCoord\n{\n  float u, v;\n};\n```\n\n```c\nstruct SMOBatch\n{\n  int16_t  unknown_box[6];\n  uint32_t startIndex;      // Starting index into the MOVI chunk.\n  uint16_t count;           // Number of indices to draw.\n  uint16_t minIndex;        // Minimum vertex index in the batch.\n  uint16_t maxIndex;        // Maximum vertex index in the batch.\n  uint8_t  flag_unknown_1;\n  uint8_t  material_id;     // Index into the MOMT chunk.\n};\n```\n\n```c\nstruct SMOColor\n{\n  uint8_t b, g, r, a;\n};\n```\n\n```c\n// MOBN - BSP Nodes\nstruct CAaBspNode\n{\n  uint16_t flags;       // Node flags (leaf, plane axis).\n  int16_t  negChild;    // Index of the negative child node.\n  int16_t  posChild;    // Index of the positive child node.\n  uint16_t nFaces;      // Number of faces in this node.\n  uint32_t faceStart;   // Starting index into the MOBR chunk.\n  float    planeDist;   // Distance of the splitting plane.\n};\n\n// MOBR - BSP Face Indices\nstruct SMOBspFace\n{\n  uint16_t indices[3];\n};\n```",
        "constants_and_flags": "flag_do_not_attenuate_vertices_based_on_distance_to_portal = 0x1\nflag_use_unified_render_path = 0x2\nflag_use_liquid_type_dbc_id = 0x4\nflag_do_not_fix_vertex_color_alpha = 0x8\n\nF_UNLIT = 0x1\nF_UNFOGGED = 0x2\nF_UNCULLED = 0x4\nF_EXTLIGHT = 0x8\nF_SIDN = 0x10\nF_WINDOW = 0x20\nF_CLAMP_S = 0x40\nF_CLAMP_T = 0x80\n\nHas BSP tree = 0x1\nHas vertex colors = 0x4\nEXTERIOR = 0x8\nEXTERIOR_LIT = 0x40\nUNREACHABLE = 0x80\nHas lights = 0x200\nHas doodads = 0x800\nLIQUIDSURFACE = 0x1000\nINTERIOR = 0x2000\nShow skybox = 0x40000\nCVERTS2 = 0x1000000\nTVERTS2 = 0x2000000",
        "relationships": "*   **WDT (World Definition Template):** WDT files contain a grid of map tiles and for each tile, they can contain a WMO. The WDT file specifies the position, rotation, and scale of the WMO in the world.\n*   **ADT (Area Data Template):** ADT files define the terrain of a map tile. They can also contain references to WMOs, including their position and rotation. Doodad sets for WMOs are also specified in the ADT files.\n*   **M2/MDX (Model):** M2 files are the primary model format for characters, creatures, and doodads. WMO files reference M2 files for doodads, which are decorative objects placed within the WMO.\n*   **BLP (Blizzard Picture):** BLP files are the texture format used in World of Warcraft. WMO files reference BLP files for the textures that are applied to the WMO's surfaces.",
        "tools": "WoW Model Viewer: A 3D model viewer for World of Warcraft that can be used to view WMO and M2 models.\nBlender WMO import/export scripts: An addon for the 3D modeling software Blender that allows for the import, export, and editing of WMO files.\nwow_wmo (Rust library): A library for the Rust programming language that provides a comprehensive set of tools for parsing, editing, and converting WMO files.\n010 Editor: A hex editor that has a template for the WMO file format. This allows for the direct viewing and editing of the raw data in a WMO file.",
        "code_examples": "```cpp\nbool CMapObj::QueryLighting ( CMapObj * this , uint32_t groupIndex , const C3Segment * seg , CImVector * color , bool * a5 ) { \n\n CMapObjGroup group = this -> groupList [ groupIndex ]; \n\n if ( ! this -> unk6 [ 16 ] || ! ( group -> unk14 & 1 ) || group -> flags & ( SMOGroup :: EXTERIOR | SMOGroup :: EXTERIOR_LIT )) { \n\n return 0 ; \n\n } \n\n World :: TriData :: resultFlags = 0 ; \n World :: TriData :: nBatches = 0 ; \n World :: TriData :: nTriIndices = 0 ; \n World :: TriData :: nVertexIndices = 0 ; \n World :: TriData :: nMatrices = 0 ; \n\n float hitT = 1.0 ; \n\n // Query the BSP tree for the group to find appropriate tris \n\n bool triRes = CMapObjGroup :: GetTris ( group , seg , & hitT , 0 , 0x8 , ( int ) & a2 + 3 , 0 ); \n\n if ( ! triRes ) { \n\n return 0 ; \n\n } \n\n // Obtain point matching intersection between segment and tri \n\n C3Vector point ; \n\n point . x = seg -> start . x + hitT * ( seg -> end . x - seg -> start . x ); \n point . y = seg -> start . y + hitT * ( seg -> end . y - seg -> start . y ); \n point . z = seg -> start . z + hitT * ( seg -> end . z - seg -> start . z ); \n\n unsigned __int16 hitPoly = word_CD8094 ; \n\n bool lightRes = CMapObjGroup :: QueryLighting ( group , & point , hitPoly , color , a5 ); \n\n return lightRes ; \n\n }\n```\n\n```cpp\nvoid CMapObjGroup::FixColorVertexAlpha () \n { \n int32_t intBatchStart ; \n\n if ( this -> transBatchCount > 0 ) \n { \n intBatchStart = this -> batchList [ this -> transBatchCount - 1 ]. maxIndex + 1 ; \n } \n else \n { \n intBatchStart = 0 ; \n } \n\n if ( this -> colorVertexCount > 0 ) \n { \n for ( int32_t i = 0 ; i < this -> colorVertexCount ; i ++ ) \n { \n CImVector * color = & this -> colorVertexList [ i ]; \n\n // Int / ext batches \n if ( i >= intBatchStart ) \n { \n int32_t v6 = ( color -> r + ( color -> a * color -> r / 64 )) / 2 ; \n int32_t v7 = ( color -> g + ( color -> a * color -> g / 64 )) / 2 ; \n int32_t v8 = ( color -> b + ( color -> a * color -> b / 64 )) / 2 ; \n\n v6 = v6 > 255 ? 255 : v6 ; \n v7 = v7 > 255 ? 255 : v7 ; \n v8 = v8 > 255 ? 255 : v8 ; \n\n color -> r = v6 ; \n color -> g = v7 ; \n color -> b = v8 ; \n\n color -> a = 255 ; \n // Trans batches \n } \n else \n { \n color -> r /= 2 ; \n color -> g /= 2 ; \n color -> b /= 2 ; \n } \n } \n } \n }\n```",
        "sources": "https://wowdev.wiki/WMO\nhttps://wowdev.wiki/WMO/Rendering",
        "detailed_findings": "/home/ubuntu/detailed_findings/2_qK9pRlWGWzDawOPNcioFi0_1769897325230_na1fn_L2hvbWUvdWJ1bnR1L3dtb19yZXBvcnQ.md"
      },
      "error": ""
    },
    {
      "input": "ADT Terrain Format Complete - Research complete ADT format including: all chunks (MHDR, MCIN, MTEX, MMDX, MMID, MWMO, MWID, MDDF, MODF, MCNK subchunks), MFBO flight bounds, MH2O liquid details, MCRF references, MCSH shadows, texture flags",
      "output": {
        "topic": "ADT Terrain Format Complete",
        "summary": "The ADT (Arclight Terrain) file format, specifically version 18 for WoW 3.3.5a, is a complex, chunk-based structure that defines a single map tile's terrain, including its geometry, texturing, and placed objects. It contains numerous data chunks like MHDR, MCIN, and 256 MCNK chunks, each with sub-chunks detailing heightmaps, normals, and liquid data. Understanding this format is crucial for building custom tools and applications that interact with WoW's game world.",
        "struct_definitions": "```c\n// MVER Chunk\nstruct MVER {\n  uint32_t version; // Always 18 for 3.3.5a\n};\n\n// MHDR Chunk\nstruct MHDR {\n  enum MHDRFlags {\n    mhdr_MFBO = 1,      // Contains an MFBO chunk.\n    mhdr_northrend = 2, // Set for Northrend maps.\n  };\n  uint32_t flags;\n  uint32_t mcin;      // Offset to MCIN chunk\n  uint32_t mtex;      // Offset to MTEX chunk\n  uint32_t mmdx;      // Offset to MMDX chunk\n  uint32_t mmid;      // Offset to MMID chunk\n  uint32_t mwmo;      // Offset to MWMO chunk\n  uint32_t mwid;      // Offset to MWID chunk\n  uint32_t mddf;      // Offset to MDDF chunk\n  uint32_t modf;      // Offset to MODF chunk\n  uint32_t mfbo;      // Offset to MFBO chunk (if flags & mhdr_MFBO)\n  uint32_t mh2o;      // Offset to MH2O chunk\n  uint32_t mtxf;      // Offset to MTXF chunk\n  uint8_t mamp_value; // Cata+, explicit MAMP chunk overrides data\n  uint8_t padding[3];\n  uint32_t unused[3];\n};\n\n// MCIN Chunk\nstruct MCIN_Entry {\n  uint32_t offset; // Absolute offset to MCNK chunk\n  uint32_t size;   // Size of the MCNK chunk\n  uint32_t flags;  // Always 0 in file, 1 when loaded in client\n  uint32_t asyncId; // Client-side use only\n};\n\nstruct MCIN {\n  MCIN_Entry entries[256];\n};\n\n// MTEX Chunk\nstruct MTEX {\n  char filenames[]; // Null-terminated strings of texture paths\n};\n\n// MMDX Chunk\nstruct MMDX {\n  char filenames[]; // Null-terminated strings of M2 model paths\n};\n\n// MMID Chunk\nstruct MMID {\n  uint32_t offsets[]; // Offsets into MMDX for model filenames\n};\n\n// MWMO Chunk\nstruct MWMO {\n  char filenames[]; // Null-terminated strings of WMO model paths\n};\n\n// MWID Chunk\nstruct MWID {\n  uint32_t offsets[]; // Offsets into MWMO for model filenames\n};\n\n// MDDF Chunk\nstruct MDDF_Entry {\n  uint32_t nameId;        // Index into MMID\n  uint32_t uniqueId;      // A unique ID for this doodad instance\n  float position[3];    // X, Y, Z coordinates\n  float rotation[3];    // Rotation in degrees\n  uint16_t scale;         // Scale factor * 1024\n  uint16_t flags;         // See MDDFFlags\n};\n\n// MODF Chunk\nstruct MODF_Entry {\n  uint32_t nameId;        // Index into MWID\n  uint32_t uniqueId;      // A unique ID for this WMO instance\n  float position[3];    // X, Y, Z coordinates\n  float rotation[3];    // Rotation in degrees\n  float extents[6];     // Bounding box\n  uint16_t flags;         // See MODFFlags\n  uint16_t doodadSet;     // Which doodad set to use from the WMO\n  uint16_t nameSet;       // Which name set to use\n  uint16_t scale;         // Scale factor\n};\n\n// MCNK Chunk Header\nstruct MCNK_Header {\n  uint32_t flags;\n  uint32_t indexX;\n  uint32_t indexY;\n  uint32_t nLayers;\n  uint32_t nDoodadRefs;\n  uint32_t ofsHeight;\n  uint32_t ofsNormal;\n  uint32_t ofsLayer;\n  uint32_t ofsRefs;\n  uint32_t ofsAlpha;\n  uint32_t sizeAlpha;\n  uint32_t ofsShadow;\n  uint32_t sizeShadow;\n  uint32_t areaid;\n  uint32_t nMapObjRefs;\n  uint16_t holes_low_res;\n  uint16_t unknown_but_used;\n  uint8_t predominantTexture[8][8];\n  uint8_t noEffectDoodad[8][8];\n  uint32_t ofsSndEmitters;\n  uint32_t nSndEmitters;\n  uint32_t ofsLiquid;\n  uint32_t sizeLiquid;\n  float position[3];\n  uint32_t ofsMCCV;\n  uint32_t ofsMCLV; // Cata+\n  uint32_t unused;\n};\n\n// MCVT Sub-chunk\nstruct MCVT {\n  float height[9*9 + 8*8];\n};\n\n// MCNR Sub-chunk\nstruct MCNR {\n  int8_t normal[3][9*9 + 8*8];\n};\n\n// MCLY Sub-chunk\nstruct MCLY_Entry {\n  uint32_t textureId; // Index into MTEX\n  uint32_t flags;\n  uint32_t offsetInMCAL;\n  int16_t effectId;\n  int16_t padding;\n};\n\n// MCRF Sub-chunk\nstruct MCRF {\n  uint32_t doodad_refs[]; // Indices into MDDF\n  uint32_t object_refs[]; // Indices into MODF\n};\n\n// MCSH Sub-chunk\nstruct MCSH {\n  uint8_t shadow_map[64 * 64 / 8]; // 1 bit per pixel\n};\n\n// MCAL Sub-chunk\n// See detailed explanation in the wiki page.\n\n// MH2O Chunk\nstruct MH2O_Header {\n  uint32_t ofsInformation;\n  uint32_t nLayers;\n  uint32_t ofsData;\n};\n\nstruct MH2O_Information {\n  uint16_t liquidType;\n  uint16_t flags;\n  float heightLevel1;\n  float heightLevel2;\n  uint8_t xOffset;\n  uint8_t yOffset;\n  uint8_t width;\n  uint8_t height;\n  uint32_t ofsBitmap;\n  uint32_t ofsVertexData;\n};\n```",
        "constants_and_flags": "### MHDR Flags\n\n*   `mhdr_MFBO` = 1: Contains an `MFBO` chunk.\n*   `mhdr_northrend` = 2: Set for Northrend maps.\n\n### MCNK Flags\n\n*   `has_mcsh` = 0x1: Has `MCSH` shadow chunk.\n*   `impass` = 0x2: Impassable terrain.\n*   `lq_river` = 0x4: River water.\n*   `lq_ocean` = 0x8: Ocean water.\n*   `lq_magma` = 0x10: Magma/lava.\n*   `lq_slime` = 0x20: Slime.\n*   `has_mccv` = 0x40: Has `MCCV` vertex color chunk.\n*   `do_not_fix_alpha_map` = 0x8000: Don't fix 63x63 alpha maps to 64x64.\n\n### MCLY Flags\n\n*   `animation_rotation` = 0x1\n*   `animation_speed` = 0x2\n*   `animation_enabled` = 0x4\n*   `overbright` = 0x8\n*   `use_alpha_map` = 0x10\n*   `alpha_map_compressed` = 0x20\n*   `use_cube_map_reflection` = 0x40",
        "relationships": "*   **WDT:** The World Definition Tile file (`.wdt`) defines which ADT tiles exist for a given map and contains global map information.\n*   **M2:** Doodads (small objects and decorations) are stored in the M2 model format and are referenced by the `MMDX` and `MDDF` chunks.\n*   **WMO:** World Map Objects (large structures like buildings and dungeons) are stored in the WMO format and are referenced by the `MWMO` and `MODF` chunks.\n*   **BLP:** Textures used for terrain and models are stored in the BLP (Blizzard Picture) format.",
        "tools": "*   **Noggit:** A popular World of Warcraft map editor that can view and edit ADT files.\n*   **010 Editor:** A hex editor with templates available for various WoW file formats, including ADT.\n*   **AdtTools:** A C# framework for manipulating ADT files.\n*   **wow-adt:** A Rust crate for parsing ADT files.",
        "code_examples": "```cpp\nunsigned offI = 0; //offset IN buffer\nunsigned offO = 0; //offset OUT buffer\nchar* buffIn; // pointer to data in adt file\nchar buffOut[4096]; // the resulting alpha map\n\nwhile( offO < 4096 )\n{\n  // fill or copy mode\n  bool fill = buffIn[offI] & 0x80;\n  unsigned n = buffIn[offI] & 0x7F;\n  offI++;\n  for( unsigned k = 0; k < n; k++ )\n  {\n    buffOut[offO] = buffIn[offI];\n    offO++;\n    if( !fill )\n      offI++;\n  }\n  if( fill ) offI++;\n}\n```",
        "sources": "https://wowdev.wiki/ADT/v18",
        "detailed_findings": "/home/ubuntu/detailed_findings/3_s90lEzSALxO9gLISmWCKrb_1769897205337_na1fn_L2hvbWUvdWJ1bnR1L2RldGFpbGVkX2ZpbmRpbmdz.md"
      },
      "error": ""
    },
    {
      "input": "WDT World Definition Table Format - Research WDT format including: MPHD flags, MAIN chunk structure, MWMO for global WMO maps, relationship to ADT files, map flags for instances/battlegrounds",
      "output": {
        "topic": "WDT World Definition Table Format",
        "summary": "WDT files are the top-level map files in WoW 3.3.5a, defining which ADT map tiles are present or referencing a global WMO for non-terrain maps. The file is chunk-based, with the MPHD chunk containing flags that control map rendering, and the MAIN chunk acting as a 64x64 grid to indicate the presence of ADT files.",
        "struct_definitions": "```c\nstruct MPHD {\n  uint32_t flags;\n  uint32_t something; // Used to initialize MAIN chunk data in some cases\n  uint32_t unused[6];\n};\n```\n\n```c\nstruct SMAreaInfo {\n  uint32_t Flag_HasADT : 1;\n  uint32_t Flag_Loaded : 1; // Set at runtime\n  uint32_t asyncId; // Set at runtime\n};\n```\n\n```c\nstruct SMMapObjDef {\n  uint32_t nameId; // Not used, filename from MWMO is used\n  uint32_t uniqueId; // Dynamically generated\n  float position[3];\n  float orientation[3];\n  float upperExtents[3];\n  float lowerExtents[3];\n  uint16_t flags;\n  uint16_t doodadSet;\n  uint16_t nameSet;\n  uint16_t pad;\n};\n```",
        "constants_and_flags": "wdt_uses_global_map_obj = 0x1\nadt_has_mccv = 0x2\nadt_has_big_alpha = 0x4\nadt_has_doodadrefs_sorted_by_size_cat = 0x8\nFLAG_LIGHTINGVERTICES = 0x10\nadt_has_upside_down_ground = 0x20",
        "relationships": "*   **ADT (Area Definition Table):** WDT files specify which ADT files are present in a map.\n*   **WMO (World Map Object):** WDT files can reference a global WMO for maps without terrain.\n*   **WDL (World Definition Low-res):** WDL files contain low-resolution heightmap data for the entire map.",
        "tools": "WDT Editor: A tool for editing WDT files.\nBLPConverter: For converting BLP files.",
        "code_examples": "```c\n// Pseudocode for parsing a WDT file\n\nfunction parseWDT(file) {\n  const mphd = readMPHD(file);\n  const main = readMAIN(file);\n\n  if (mphd.flags & 0x1) {\n    const mwmo = readMWMO(file);\n    const modf = readMODF(file);\n    // This is a WMO-based map\n  } else {\n    // This is an ADT-based map\n    for (let y = 0; y < 64; y++) {\n      for (let x = 0; x < 64; x++) {\n        if (main.areaInfo[y][x].Flag_HasADT) {\n          // Load ADT file for this tile\n        }\n      }\n    }\n  }\n}\n```",
        "sources": "https://wowdev.wiki/WDT",
        "detailed_findings": "/home/ubuntu/detailed_findings/4_REZourATzyhqOIA3QJehJA_1769897172581_na1fn_L2hvbWUvdWJ1bnR1L3dkdF9yZXNlYXJjaA.md"
      },
      "error": ""
    },
    {
      "input": "BLP Texture Format Complete - Research BLP2 format details including: all compression types, alpha channel handling, mipmap generation, palette format, DXT variants (DXT1/DXT3/DXT5), encoding/decoding algorithms",
      "output": {
        "topic": "BLP2 Texture Format",
        "summary": "BLP2 is a texture format used by Blizzard Entertainment in games like World of Warcraft. It supports various compression methods, including DXT1, DXT3, and DXT5, as well as uncompressed and palettized formats. The file structure consists of a header, mipmap offsets and sizes, and the texture data for each mipmap level.",
        "struct_definitions": "```c\nstruct BLPHeader {\n  uint32_t magic; // 'BLP2'\n  uint32_t formatVersion; // always 1\n  uint8_t colorEncoding; // 1: uncompressed, 2: DXTC, 3: plain A8R8G8B8\n  uint8_t alphaSize; // 0, 1, or 8\n  uint8_t preferredFormat;\n  uint8_t hasMips; // 0: no mipmaps, 1: mipmaps\n  uint32_t width;\n  uint32_t height;\n  uint32_t mipOffsets[16];\n  uint32_t mipSizes[16];\n  union {\n    struct BlpPalPixel {\n      uint8_t b, g, r, pad;\n    } palette[256];\n    struct {\n      uint32_t headerSize;\n      char headerData[1020];\n    } jpeg;\n  } extended;\n};\n```",
        "constants_and_flags": "colorEncoding:\n1 = Uncompressed\n2 = DXTC (DXT1, DXT3, DXT5)\n3 = Plain A8R8G8B8 (Cataclysm)\n\nalphaSize:\n0 = No alpha\n1 = 1-bit alpha\n8 = 8-bit alpha",
        "relationships": "- BLP files are used for textures in various WoW file formats, such as M2 (models) and WMO (World Map Objects).\n- The DXT compression formats (DXT1, DXT3, DXT5) are standard S3 Texture Compression formats.",
        "tools": "BLPConverter: A tool for converting BLP files to other formats.\nPillow: A Python imaging library with support for reading BLP files.\nwow_blp: A Rust crate for parsing BLP files.",
        "code_examples": "```javascript\n// Calculating valid mipmap size\nif ((textureFormat == \"DXT5\") || (textureFormat == \"DXT3\")) {\n    validSize = Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n}\nif ((textureFormat == \"RGB_DXT1\") || (textureFormat == \"RGBA_DXT1\")) {\n    validSize = Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n}\n```",
        "sources": "https://wowdev.wiki/BLP\nhttps://github.com/Pinta365/blp\nhttp://justsolve.archiveteam.org/wiki/BLP",
        "detailed_findings": "/home/ubuntu/detailed_findings/5_LGMM41BRv3vCfXeSD6pHmx_1769897162393_na1fn_L2hvbWUvdWJ1bnR1L2JscF9yZXNlYXJjaA.md"
      },
      "error": ""
    },
    {
      "input": "Skin and LOD Files - Research .skin file format for M2 models including: vertex indices, triangle batches, bone combinations, texture units, render batches, LOD system (skin0-skin3), bone lookup tables",
      "output": {
        "topic": "Skin and LOD Files",
        "summary": "The .skin file format, introduced in World of Warcraft: Wrath of the Lich King, is a critical component for rendering M2 models with varying levels of detail (LODs). It separates the submesh and LOD data from the main M2 file, allowing the game to load simplified versions of models at a distance to improve performance. The format specifies vertex and index lookup tables, bone mappings, texture units, and render batches for each LOD, enabling a flexible and efficient rendering pipeline.",
        "struct_definitions": "```c\nstruct M2SkinProfile\n{\n  uint32_t                magic;                         // 'SKIN'\n  M2Array<unsigned short> vertices;\n  M2Array<unsigned short> indices;\n  M2Array<ubyte4>         bones;\n  M2Array<M2SkinSection>  submeshes;\n  M2Array<M2Batch>        batches;\n  uint32_t                boneCountMax;\n  M2Array<M2ShadowBatch>  shadow_batches;\n};\n\nstruct M2SkinSection\n{\n  uint16_t skinSectionId;\n  uint16_t Level;\n  uint16_t vertexStart;\n  uint16_t vertexCount;\n  uint16_t indexStart;\n  uint16_t indexCount;\n  uint16_t boneCount;\n  uint16_t boneComboIndex;\n  uint16_t boneInfluences;\n  uint16_t centerBoneIndex;\n  C3Vector centerPosition;\n  C3Vector sortCenterPosition;\n  float sortRadius;\n};\n\nstruct M2Batch\n{\n  uint8_t flags;\n  int8_t priorityPlane;\n  uint16_t shader_id;\n  uint16_t skinSectionIndex;\n  uint16_t geosetIndex;\n  uint16_t colorIndex;\n  uint16_t materialIndex;\n  uint16_t materialLayer;\n  uint16_t textureCount;\n  uint16_t textureComboIndex;\n  uint16_t textureCoordComboIndex;\n  uint16_t textureWeightComboIndex;\n  uint16_t textureTransformComboIndex;\n};\n\nstruct M2ShadowBatch\n{\n  uint8_t  flags;          // 0x1: Casters don't have shadows. Appears on some doodads.\n  uint8_t  flags2;\n  uint16_t ground_type;\n  int16_t  bone_index;\n  uint16_t submesh_id;\n  uint16_t vertex_count;\n  uint16_t index_count;\n  uint32_t vertex_offset;\n  uint32_t index_offset;\n};\n```",
        "constants_and_flags": "### Magic Number\n- `SKIN`: The first 4 bytes of a .skin file, identifying it as such.\n\n### M2Batch Flags\n- `0x1`: Invert texture mapping\n- `0x2`: Transform\n- `0x4`: Project texture\n- `0x10`: Unlit\n- `0x40`: Unfogged\n\n### M2ShadowBatch Flags\n- `0x1`: Casters don't have shadows. Appears on some doodads.",
        "relationships": "- **M2 Files:** .skin files are intrinsically linked to .m2 model files. The .skin file references vertex and bone data within the .m2 file, and the .m2 file relies on the .skin file for LOD information.\n- **CreatureDisplayInfo.dbc and ItemDisplayInfo.dbc:** These database files use geoset data to customize the appearance of creatures and items, which directly corresponds to the submesh IDs defined in the .skin file.",
        "tools": "- **jM2converter:** A universal converter for WoW M2 formats.\n- **LKBC_Converter:** A tool to convert M2 models from WotLK to The Burning Crusade format.",
        "code_examples": "### C++ Example for Applying Monster Geosets\n\n```cpp\nvoid ApplyMonsterGeosets(CM2Model *pModel, CreatureDisplayInfoRec *pDisplayInfo, CharacterComponent *pCharacterComponent)\n{\n    if (pModel && pDisplayInfo)\n    {\n        CreatureModelData *modelDataRec = ClientDB::CreatureModelDataDB::GetRow(pCharacterComponent->ModelId);\n        \n        if (!modelDataRec)\n            __debugbreak();\n\n        if (modelDataRec->CreatureGeosetDataID)\n        {\n            CM2Model::SetGeometryVisible(pModel, 1, 899, false);\n\n            int displayInfoID = pDisplayInfo->ID;\n\n            auto geosetDatas = ClientDB::CreatureDisplayInfoGeosetDataDB::GetRows([](auto cdigd) { return cdigd->CreatureDisplayInfoID == displayInfoID; });\n\n            for (auto geosetData : geosetDatas)\n            {\n                int meshId1 = 100 * (geosetData->GeosetIndex + 1);\n                CM2Model::SetGeometryVisible(pModel, meshId1, meshId1 + 99, false);\n                int meshId2 = meshId1 + geosetData->GeosetValue;\n                CM2Model::SetGeometryVisible(pModel, meshId2, meshId2, true);\n            }\n        }\n    }\n}\n```\n\n### JavaScript Example for WotLK Runtime Shader Selection\n\n```javascript\nfunction CM2Shared.sub837A40() \n{\n  /* Some code is skipped */\n  \n  if ( !((_BYTE)field[4]->field_4 & 8) )\n  {\n    M2Vertex* override_vertices = SMemNew(sizeof (M2Vertex) * skinFile->indices.count);\n\n    // 2. zero-initialize (but will be overridden with real vertices in 3.)\n    // 3. Copy data from initial vertex of m2 and override boneIndexes\n    \n    for (int meshIndex = 0; meshIndex < skinFile->submeshes.count; ++meshIndex)\n    {\n      M2SkinSection* subMesh = skinFile->submeshes.data[meshIndex];\n\n      for (int vertIndex = subMesh->StartVertex; vertIndex < (subMesh->StartVertex + subMesh->vertices.count); ++vertIndex)\n      {\n        override_vertices[vertIndex] = m_data->vertices.data[skinFile->indices.data[vertIndex]];\n\n        for (int boneInd = 0; boneInd < subMesh->boneInfluences; ++boneInd)\n        {\n          override_vertices[vertIndex].bone_indices[boneInd] =\n            m_data->bone_lookup_table.data[subMesh->StartBones + skinFile->properties.data[4*vertIndex + boneInd]];\n        }\n      }\n    }\n  \n    // 4. Override bone lookup table and in m2 file\n    for (int i = 0; i < m_data->nBoneLookupTable; ++i)\n      m_data->bone_lookup_table.data[i] = i;\n \n    // 5. Override indicies in skin file\n    for (int j = 0; j < skinFile->indices.count; ++j)\n      skinFile->indices.data[j] = j;\n \n    // 6. Override vertex array from m2 with new data\n    if ( skinFile->indices.count <= m_data->vertices.count )\n    {\n      memcpy(m_data->vertices.data, override_vertices, sizeof (M2Vertex) * skinFile->indices.count);\n      SMemFree (override_vertices);\n    }\n    else\n    {\n      field_8 |= 8u;\n      m_data->vertices.data = override_vertices;\n    }\n  \n    m_data->vertices.count = skinFile->indices.count;\n  }\n  \n  // 7. Override batch flags\n  if ( !((_BYTE)field[4]->field_4 & 8) )\n  {\n    for ( int i = 0; i < skinFile->batches.count; i++)\n    {\n      if ( skinFile->batches.data[i].op_count > 1u )\n        skinFile->batches.data[i - skinFile->batches.data[i].layer].flags |= 0x40u;\n    }\n  \n    for ( int i = 0; i < skinFile->batches.count; i++)\n    {\n      if ( skinFile->batches.data[i].layer )\n      {\n        if ( skinFile->batches.data[i - skinFile->batches.data[i].layer].flags & 0x40 )\n          skinFile->batches.data[i].flags |= 0x40u;\n      }\n    }\n  }\n}\n```",
        "sources": "https://wowdev.wiki/M2/.skin",
        "detailed_findings": "/home/ubuntu/detailed_findings/6_MCnew7TWrsDvGFsmnAHsku_1769897194974_na1fn_L2hvbWUvdWJ1bnR1L3NraW5fbG9kX2ZpbGVz.md"
      },
      "error": ""
    },
    {
      "input": "Animation System and ANIM Files - Research M2 animation system including: animation sequences, bone transformations, interpolation types (none/linear/hermite/bezier), global sequences, animation lookup, external .anim files",
      "output": {
        "topic": "Animation System and ANIM Files",
        "summary": "The World of Warcraft 3.3.5a animation system is primarily centered around the M2 model format. M2 files contain the core model data, including vertices, bones, and animation sequences. Animations can be stored either internally within the M2 file or externally in separate `.anim` files, which are loaded on demand. The system supports various interpolation methods for smooth keyframe animation, including linear, Bezier, and Hermite, allowing for complex and realistic character and creature movements. Global sequences provide a mechanism for continuous, looping animations that are independent of the main animation sequences.",
        "struct_definitions": "```c\n// Represents a single animation sequence\nstruct M2Animation {\n    uint16_t animation_id;          // Animation ID from AnimationData.dbc\n    uint16_t sub_animation_id;      // Sub-animation ID, used for variations\n    uint32_t length;                // Duration of the animation in milliseconds\n    float moving_speed;             // Speed of the model during this animation\n    uint32_t flags;                 // Animation flags\n    int16_t probability;            // Likelihood of this animation playing\n    uint16_t unused;                // Padding\n    uint32_t d1;                    // Unknown\n    uint32_t d2;                    // Unknown\n    uint32_t playback_speed;        // Speed at which the animation is played\n    float box_x, box_y, box_z;      // Bounding box for the animation\n    float box_radius;               // Bounding sphere radius\n    int16_t next_animation;         // Next animation in the sequence\n    uint16_t index;                 // Index into the sequence array\n};\n\n// Generic animation track with keyframes\nstruct M2Track<T> {\n    uint16_t interpolation_type;    // 0: none, 1: linear, 2: hermite, 3: bezier\n    int16_t global_sequence;        // Global sequence ID, -1 if none\n    M2Array<uint32_t> timestamps;   // Timestamps for each keyframe\n    M2Array<T> values;              // Keyframe values\n};\n\n// Bone definition\nstruct M2Bone {\n    int32_t key_bone_id;            // ID of the bone\n    uint32_t flags;                 // Bone flags\n    int16_t parent_bone;            // Parent bone index\n    uint16_t submesh_id;            // Geometric data for the bone\n    uint16_t unknown;               // Unknown\n    M2Track<C3Vector> translation;  // Translation keyframes\n    M2Track<C4Quaternion> rotation; // Rotation keyframes\n    M2Track<C3Vector> scaling;      // Scaling keyframes\n    C3Vector pivot;                 // Pivot point for the bone\n};\n\n// Quaternion for rotations\nstruct C4Quaternion {\n    float x, y, z, w;\n};\n\n// 3D Vector for translations and scaling\nstruct C3Vector {\n    float x, y, z;\n};\n\n// Resolved animation track data with keyframes loaded into memory\nstruct ResolvedTrack<T> {\n    uint16_t interpolation_type;    // 0=None, 1=Linear, 2=Bezier, 3=Hermite\n    int16_t global_sequence;        // Global sequence index (65535 = no global sequence)\n    Vec<Vec<u32>> timestamps;       // Timestamps per animation sequence\n    Vec<Vec<T>> values;             // Values per animation sequence\n};\n```",
        "constants_and_flags": "### Animation Flags\n\n- `0x0001`: Looping animation\n- `0x0002`: No blending\n- `0x0004`: Stop at end\n- `0x0008`: Start at random time\n- `0x0010`: Play backwards\n- `0x0020`: Play once and hold\n- `0x0040`: Play once and stop\n- `0x0080`: Primary bone sequence\n- `0x0100`: Secondary bone sequence\n\n### Interpolation Types\n\n- `0`: None (no interpolation)\n- `1`: Linear\n- `2`: Hermite\n- `3`: Bezier",
        "relationships": "- **AnimationData.dbc:** This client database file contains the names and metadata for each animation ID used in the `M2Animation` struct.\n- **M2 Model Format:** The animation system is intrinsically linked to the M2 model format, which defines the skeleton, bones, and animation sequences.\n- **.skin Files:** These files define the submeshes and vertex data that are animated by the bone transformations.\n- **Game Client:** The game client is responsible for loading the M2 and `.anim` files, processing the animation data, and rendering the animated models in the game world.",
        "tools": "- **warcraft-rs:** A Rust library and CLI toolset for parsing and converting various WoW file formats, including M2 and `.anim` files.\n- **WoW Model Viewer:** A popular tool for viewing and exploring WoW models and their animations.\n- **Blender M2 Import/Export Add-ons:** Various Blender add-ons exist for importing, editing, and exporting M2 models, which often include support for animations.",
        "code_examples": "```rust\nfn interpolate_track<T: Lerp>(track: &ResolvedTrack<T>, time: f64) -> T {\n    let (timestamps, values) = track.get_keyframes_for_current_animation();\n\n    if timestamps.is_empty() {\n        return track.default_value;\n    }\n\n    let index = find_timestamp_index(timestamps, time);\n\n    if index >= timestamps.len() - 1 {\n        return values.last().clone();\n    }\n\n    let time1 = timestamps[index];\n    let time2 = timestamps[index + 1];\n    let value1 = &values[index];\n    let value2 = &values[index + 1];\n\n    let t = (time - time1) / (time2 - time1);\n\n    match track.interpolation_type {\n        0 => value1.clone(), // None\n        1 => value1.lerp(value2, t), // Linear\n        2 | 3 => { // Bezier/Hermite (simplified as linear)\n            value1.lerp(value2, t)\n        }\n        _ => value1.clone(),\n    }\n}\n```",
        "sources": "https://wowdev.wiki/M2\nhttps://wowdev.wiki/M2/AnimationList\nhttps://github.com/wowemulation-dev/warcraft-rs",
        "detailed_findings": "/home/ubuntu/detailed_findings/7_uEhY966U6uUuRYzeC3ErJN_1769897422414_na1fn_L2hvbWUvdWJ1bnR1L3Jlc2VhcmNoL2RldGFpbGVkX2ZpbmRpbmdz.md"
      },
      "error": ""
    },
    {
      "input": "Spell Visual System - Research spell visuals including: SpellVisualKit DBC, SpellVisualEffectName, spell missiles, spell impacts, area effects, channeling visuals, how visuals connect to M2 models",
      "output": {
        "topic": "Spell Visual System",
        "summary": "The spell visual system in World of Warcraft 3.3.5a is a complex system that uses several DBC files to define and control the visual effects of spells. The main files are `SpellVisual.dbc`, `SpellVisualKit.dbc`, and `SpellVisualEffectName.dbc`. These files define the different stages of a spell's visual effect, from pre-cast to impact, and link to M2 models for the actual visuals.",
        "struct_definitions": "```c\nstruct SpellVisualRec {\n    uint32_t m_ID;\n    uint32_t m_precastKit; // The visual effect used for the casting\n    uint32_t m_castKit; // The visual effect used for the cast where the spell occurs\n    uint32_t m_impactKit; // The visual effect used for the target\n    uint32_t m_stateKit; // The visual effect that can be seen while this buff/debuff remains on the target\n    uint32_t m_stateDoneKit;\n    uint32_t m_channelKit; // The visual effect used while channeling a spell\n    uint32_t m_hasMissile; // Boolean\n    uint32_t m_missileModel; // The visual effect used for the spell missile\n    uint32_t m_missilePathType;\n    uint32_t m_missileDestinationAttachment;\n    uint32_t m_missileSound;\n    uint32_t m_animEventSoundID;\n    uint32_t m_flags; // The visual effect used at the center of an AOE spell probably used for other things as well\n    uint32_t m_casterImpactKit;\n    uint32_t m_targetImpactKit; // Previous documentation had swapped this with m_flags.\n    uint32_t m_missileAttachment;\n    uint32_t m_missileFollowGroundHeight;\n    uint32_t m_missileFollowGroundDropSpeed;\n    uint32_t m_missileFollowGroundApproach;\n    uint32_t m_missileFollowGroundFlags;\n    uint32_t m_missileMotion;\n    uint32_t m_missileTargetingKit;\n    uint32_t m_instantAreaKit;\n    uint32_t m_impactAreaKit;\n    uint32_t m_persistentAreaKit; // The visual effect for AOE spells\n    float m_missileCastOffset[3];\n    float m_missileImpactOffset[3];\n};\n\nstruct SpellVisualKitRec {\n  uint32_t m_ID;\n  uint32_t m_kitType;\n  uint32_t m_anim;\n  foreign_key<uint32_t, &SpellVisualEffectNameRec::m_ID> m_headEffect;\n  foreign_key<uint32_t, &SpellVisualEffectNameRec::m_ID> m_chestEffect;\n  foreign_key<uint32_t, &SpellVisualEffectNameRec::m_ID> m_baseEffect;\n  foreign_key<uint32_t, &SpellVisualEffectNameRec::m_ID> m_leftHandEffect;\n  foreign_key<uint32_t, &SpellVisualEffectNameRec::m_ID> m_rightHandEffect;\n  foreign_key<uint32_t, &SpellVisualEffectNameRec::m_ID> m_breathEffect;\n  foreign_key<uint32_t, &SpellVisualEffectNameRec::m_ID> m_specialEffect[3];\n  int32_t m_characterProcedure;\n  float m_characterParam[4];\n  foreign_key<uint32_t, &SoundEntriesRec::m_ID> m_soundID;\n  foreign_key<uint32_t, &SpellEffectCameraShakesRec::m_ID> m_shakeID;\n};\n\nstruct SpellVisualEffectNameRec {\n  uint32_t m_ID;\n  stringref name;\n  stringref m_fileName;\n  float m_areaEffectSize;\n  float scale;\n  float minAllowedScale;\n  float minAllowedScale;\n};\n```",
        "constants_and_flags": "LOOP_ANIMATION = 0x40\n\nUNITEFFECTSPECIALS:\nSPECIALEFFECT_LOOTART = 0x0\nSPECIALEFFECT_LEVELUP = 0x1\nSPECIALEFFECT_FOOTSTEPSPRAYSNOW = 0x2\nSPECIALEFFECT_FOOTSTEPSPRAYSNOWWALK = 0x3\nSPECIALEFFECT_FOOTSTEPDIRT = 0x4\nSPECIALEFFECT_FOOTSTEPDIRTWALK = 0x5\nSPECIALEFFECT_COLDBREATH = 0x6\nSPECIALEFFECT_UNDERWATERBUBBLES = 0x7\nSPECIALEFFECT_COMBATBLOODSPURTFRONT = 0x8\nSPECIALEFFECT_UNUSED = 0x9\nSPECIALEFFECT_COMBATBLOODSPURTBACK = 0xA\nSPECIALEFFECT_HITSPLATPHYSICALSMALL = 0xB\nSPECIALEFFECT_HITSPLATPHYSICALBIG = 0xC\nSPECIALEFFECT_HITSPLATHOLYSMALL = 0xD\nSPECIALEFFECT_HITSPLATHOLYBIG = 0xE\nSPECIALEFFECT_HITSPLATFIRESMALL = 0xF\nSPECIALEFFECT_HITSPLATFIREBIG = 0x10\nSPECIALEFFECT_HITSPLATNATURESMALL = 0x11\nSPECIALEFFECT_HITSPLATNATUREBIG = 0x12\nSPECIALEFFECT_HITSPLATFROSTSMALL = 0x13\nSPECIALEFFECT_HITSPLATFROSTBIG = 0x14\nSPECIALEFFECT_HITSPLATSHADOWSMALL = 0x15\nSPECIALEFFECT_HITSPLATSHADOWBIG = 0x16\nSPECIALEFFECT_COMBATBLOODSPURTFRONTLARGE = 0x17\nSPECIALEFFECT_COMBATBLOODSPURTBACKLARGE = 0x18\nSPECIALEFFECT_FIZZLEPHYSICAL = 0x19\nSPECIALEFFECT_FIZZLEHOLY = 0x1A\nSPECIALEFFECT_FIZZLEFIRE = 0x1B\nSPECIALEFFECT_FIZZLENATURE = 0x1C\nSPECIALEFFECT_FIZZLEFROST = 0x1D\nSPECIALEFFECT_FIZZLESHADOW = 0x1E\nSPECIALEFFECT_COMBATBLOODSPURTGREENFRONT = 0x1F\nSPECIALEFFECT_COMBATBLOODSPURTGREENFRONTLARGE = 0x20\nSPECIALEFFECT_COMBATBLOODSPURTGREENBACK = 0x21\nSPECIALEFFECT_COMBATBLOODSPURTGREENBACKLARGE = 0x22\nSPECIALEFFECT_FOOTSTEPSPRAYWATER = 0x23\nSPECIALEFFECT_FOOTSTEPSPRAYWATERWALK = 0x24\nSPECIALEFFECT_CHARACTERSHAPESHIFT = 0x25\nSPECIALEFFECT_COMBATBLOODSPURTBLACKFRONT = 0x26\nSPECIALEFFECT_COMBATBLOODSPURTBLACKFRONTLARGE = 0x27\nSPECIALEFFECT_COMBATBLOODSPURTBLACKBACK = 0x28\nSPECIALEFFECT_COMBATBLOODSPURTBLACKBACKLARGE = 0x29\nSPECIALEFFECT_RES_EFFECT = 0x2A\nNUM_UNITEFFECTSPECIALS = 0x2B\nSPECIALEFFECT_NONE = 0xFFFFFFFF\n\nUNITEFFECTATTACHPPOINT:\nUNITEFFECT_ATTACHBASE = 0x0\nUNITEFFECT_ATTACHHEAD = 0x1\nUNITEFFECT_ATTACHLEFTHAND = 0x2\nUNITEFFECT_ATTACHRIGHTHAND = 0x3\nUNITEFFECT_ATTACHNONE = 0x4\nUNITEFFECT_ATTACHBREATH = 0x5\nUNITEFFECT_ATTACHCHEST = 0x6\nUNITEFFECT_ATTACHSPECIAL1 = 0x7\nUNITEFFECT_ATTACHSPECIAL2 = 0x8\nUNITEFFECT_ATTACHSPECIAL3 = 0x9\nUNITEFFECT_ATTACHCHESTBLOODBACK = 0xA\nUNITEFFECT_ATTACHCHESTBLOODFRONT = 0xB\nNUM_UNITEFFECTATTACHPOINTS = 0xC\nUNITEFFECT_INVALID = 0xFFFFFFFF",
        "relationships": "- The Spell Visual System is intrinsically linked to the M2 model format, as it references M2 files for spell visuals, missiles, and impacts.\n- It connects to the sound system via `SoundEntries.dbc` to play sounds associated with spell visuals.\n- Camera effects are triggered through `SpellEffectCameraShakes.dbc`.\n- The system is configured through a series of interconnected DBC files, primarily `SpellVisual.dbc`, `SpellVisualKit.dbc`, and `SpellVisualEffectName.dbc`.",
        "tools": "WDBXEditor: A communal program to edit DBC, DB2, WDB, ADB and DBCache files.\nSpellWork: A tool for spell-related DBC editing.\nWoW Database Editor: A modular database editor for TrinityCore-based servers.",
        "code_examples": "```c\nstruct SpellVisualRec {\n    uint32_t m_ID;\n    uint32_t m_precastKit; // The visual effect used for the casting\n    uint32_t m_castKit; // The visual effect used for the cast where the spell occurs\n    uint32_t m_impactKit; // The visual effect used for the target\n    uint32_t m_stateKit; // The visual effect that can be seen while this buff/debuff remains on the target\n    uint32_t m_stateDoneKit;\n    uint32_t m_channelKit; // The visual effect used while channeling a spell\n    uint32_t m_hasMissile; // Boolean\n    uint32_t m_missileModel; // The visual effect used for the spell missile\n    uint32_t m_missilePathType;\n    uint32_t m_missileDestinationAttachment;\n    uint32_t m_missileSound;\n    uint32_t m_animEventSoundID;\n    uint32_t m_flags; // The visual effect used at the center of an AOE spell probably used for other things as well\n    uint32_t m_casterImpactKit;\n    uint32_t m_targetImpactKit; // Previous documentation had swapped this with m_flags.\n    uint32_t m_missileAttachment;\n    uint32_t m_missileFollowGroundHeight;\n    uint32_t m_missileFollowGroundDropSpeed;\n    uint32_t m_missileFollowGroundApproach;\n    uint32_t m_missileFollowGroundFlags;\n    uint32_t m_missileMotion;\n    uint32_t m_missileTargetingKit;\n    uint32_t m_instantAreaKit;\n    uint32_t m_impactAreaKit;\n    uint32_t m_persistentAreaKit; // The visual effect for AOE spells\n    float m_missileCastOffset[3];\n    float m_missileImpactOffset[3];\n};\n```",
        "sources": "https://wowdev.wiki/DB/SpellVisualKit\nhttps://wowdev.wiki/DB/SpellVisualEffectName\nhttps://wowdev.wiki/DB/SpellVisual",
        "detailed_findings": "/home/ubuntu/detailed_findings/8_xgUVdxhq2vS6HMmz7rLyOH_1769897281006_na1fn_L2hvbWUvdWJ1bnR1L2RldGFpbGVkX2ZpbmRpbmdz.md"
      },
      "error": ""
    },
    {
      "input": "Character Customization System - Research character creation including: CharSections DBC, CharacterFacialHairStyles, CharHairGeosets, CreatureDisplayInfo, race/gender model variations, skin colors, face options, hair styles",
      "output": {
        "topic": "Character Customization System",
        "summary": "The character customization system in World of Warcraft 3.3.5a is primarily managed through a series of DBC files. These files define everything from skin and hair color to facial hair and geosets, and are interconnected to create the final character model. Key files include CharSections.dbc, CharacterFacialHairStyles.dbc, CharHairGeosets.dbc, and CreatureDisplayInfo.dbc, which work together to control the visual appearance of characters and NPCs.",
        "struct_definitions": "```cpp\nstruct CharSectionsRec {\n  uint32_t m_ID;\n  uint32_t m_raceID;\n  uint32_t m_sexID;\n  uint32_t m_baseSection;\n  uint32_t m_variationIndex;\n  uint32_t m_colorIndex;\n  stringref m_TextureName[3];\n  uint32_t m_flags;\n};\n\nstruct CharacterFacialHairStylesRec {\n  uint32_t m_RaceID;\n  uint32_t m_SexID;\n  uint32_t m_VariationID;\n  uint32_t m_BeardGeoset;\n  uint32_t m_MoustacheGeoset;\n  uint32_t m_SideburnGeoset;\n  uint32_t otherGeosets[3];\n};\n\nstruct CharHairGeosetsRec {\n  uint32_t m_ID;\n  uint32_t m_RaceID;\n  uint32_t m_SexID;\n  uint32_t m_VariationID;\n  uint32_t m_GeosetID;\n  uint32_t m_Showscalp;\n};\n\nstruct CreatureDisplayInfoRec {\n  uint32_t m_ID;\n  uint32_t m_modelID;\n  uint32_t m_soundID;\n  uint32_t m_extendedDisplayInfoID;\n  float m_creatureModelScale;\n  uint32_t m_creatureModelAlpha;\n  stringref m_textureVariation[3];\n  uint32_t m_sizeClass;\n  uint32_t m_bloodID;\n  uint32_t m_NPCSoundID;\n};\n\nstruct CreatureDisplayInfoExtraRec {\n  uint32_t m_ID;\n  uint32_t m_DisplayRaceID;\n  uint32_t m_DisplaySexID;\n  uint32_t m_SkinID;\n  uint32_t m_FaceID;\n  uint32_t m_HairStyleID;\n  uint32_t m_HairColorID;\n  uint32_t m_FacialHairID;\n  uint32_t m_NPCItemDisplay[10];\n  uint32_t m_flags;\n  stringref m_BakeName;\n};\n```",
        "constants_and_flags": "CharSections.dbc Flags:\nPlayable/CharacterCreate = 0x1\nBarbershop = 0x2\nDeath Knight texture = 0x4\nNPC skin = 0x8\nRegular skin = 0x10\nSilhouette texture = 0x100\n\nCharacterFacialHairStyles.dbc Geoset Groups:\nChin Hair (Night Elves) = group 1\nMustache (Night Elves) = group 2\nEyebrows (Night Elves) = group 3\nGeoset Group 16 = group 16\nSmall/Big Ears (Blood Elves) = group 17\n\nCreatureDisplayInfo.dbc Opacity:\nMin Opacity = 0\nMax Opacity = 255",
        "relationships": "*   **CreatureDisplayInfo.dbc** links to **CreatureDisplayInfoExtra.dbc** to provide detailed customization for character-based models.\n*   **CreatureDisplayInfoExtra.dbc** references several other DBCs to define specific features:\n    *   **ChrRaces.dbc** for the character's race.\n    *   **CharSections.dbc** for skin, face, and hair color textures.\n    *   **CharHairGeosets.dbc** for hair styles.\n    *   **CharacterFacialHairStyles.dbc** for facial hair styles.\n    *   **ItemDisplayInfo.dbc** for equipped items like helms and shoulders.\n*   **CharSections.dbc** defines the texture variations for different character features, categorized by `GeneralType` (skin, face, hair, etc.).\n*   **CharHairGeosets.dbc** connects hair styles to specific 3D model geosets.\n*   **CharacterFacialHairStyles.dbc** defines the different facial hair combinations by referencing geosets.",
        "tools": "DBCUtil: A command-line tool for converting DBC files to and from CSV format.\nTaliis: A GUI-based DBC editor.\nLadik's MPQ Editor: A tool for opening and extracting files from MPQ archives.\nWoW Model Viewer: A tool for viewing and animating World of Warcraft models, which can be used to visualize character customizations.",
        "code_examples": "```cpp\nstruct CharHairGeosetsRec {\n  uint32_t m_ID;\n  uint32_t m_RaceID;\n  uint32_t m_SexID;\n  uint32_t m_VariationID;\n  uint32_t m_GeosetID;\n  uint32_t m_Showscalp;\n};\n```",
        "sources": "https://wowdev.wiki/DB/CharSections\nhttps://wowdev.wiki/DB/CharacterFacialHairStyles\nhttps://wowdev.wiki/DB/CharHairGeosets\nhttps://wowdev.wiki/DB/CreatureDisplayInfo\nhttps://wowdev.wiki/DB/CreatureDisplayInfoExtra",
        "detailed_findings": "/home/ubuntu/detailed_findings/9_dycjJFfRRBSD46jwU62sgS_1769897291651_na1fn_L2hvbWUvdWJ1bnR1L2NoYXJzZWN0aW9uc19yZXNlYXJjaA.md"
      },
      "error": ""
    },
    {
      "input": "Mount and Creature Models - Research mount/creature rendering including: CreatureModelData DBC, CreatureDisplayInfo, attachment points for riders, mount animations, creature scaling, model variations",
      "output": {
        "topic": "Mount and Creature Models",
        "summary": "This research provides a detailed technical overview of mount and creature models in World of Warcraft 3.3.5a. The investigation covers the structure and fields of the `CreatureModelData.dbc` and `CreatureDisplayInfo.dbc` files, which define model properties, textures, and scaling. Additionally, the M2 model format is examined, with a focus on attachment points that are crucial for correctly positioning riders on mounts.",
        "struct_definitions": "```c\n// Found in CreatureModelData.dbc\nstruct CreatureModelDataRec {\n  uint32_t m_ID; // Unique identifier\n  uint32_t m_flags; // Bitmask of flags for model properties\n  char* m_ModelName; // Path to the M2 model file\n  uint32_t m_sizeClass; // Affects blood splat size and death thud sound\n  float m_modelScale; // Base scale of the model\n  uint32_t m_bloodID; // Foreign key to UnitBloodLevels.dbc\n  uint32_t m_footprintTextureID; // Foreign key to FootprintTextures.dbc\n  float m_footprintTextureLength; // Length of the footprint texture\n  float m_footprintTextureWidth; // Width of the footprint texture\n  float m_footprintParticleScale; // Scale of the footprint particle effect\n  uint32_t m_foleyMaterialID; // ID of the foley material\n  uint32_t m_footstepShakeSize; // Foreign key to CameraShakes.dbc for footstep camera shake\n  uint32_t m_deathThudShakeSize; // Foreign key to CameraShakes.dbc for death thud camera shake\n  uint32_t m_soundID; // Foreign key to CreatureSoundData.dbc\n  float m_collisionWidth; // The width of the model's collision box\n  float m_collisionHeight; // The height of the model's collision box\n  float m_mountHeight; // The height at which a rider is positioned on the mount\n  float m_geoBoxMin[3]; // The minimum coordinates of the model's geometry box\n  float m_geoBoxMax[3]; // The maximum coordinates of the model's geometry box\n  float m_worldEffectScale; // Scale of world effects on the model\n  float m_attachedEffectScale; // Scale of effects attached to the model\n  float m_missileCollisionRadius; // Radius of the missile collision sphere\n  float m_missileCollisionPush; // Push value for missile collision\n  float m_missileCollisionRaise; // Raise value for missile collision\n};\n```\n\n```c\n// Found in CreatureDisplayInfo.dbc\nstruct CreatureDisplayInfoRec {\n  uint32_t m_ID; // Unique identifier for the display info\n  uint32_t m_modelID; // Foreign key to CreatureModelData.dbc\n  uint32_t m_soundID; // Foreign key to CreatureSoundData.dbc\n  uint32_t m_extendedDisplayInfoID; // Foreign key to CreatureDisplayInfoExtra.dbc\n  float m_creatureModelScale; // The scale of the creature\n  uint32_t m_creatureModelAlpha; // The opacity of the creature (0-255)\n  char* m_textureVariation[3]; // Paths to alternate textures\n  uint32_t m_sizeClass;\n  uint32_t m_bloodID; // Foreign key to UnitBlood.dbc\n  uint32_t m_NPCSoundID; // Foreign key to NPCSounds.dbc\n};\n```\n\n```c\n// Found in M2 model files\nstruct M2Attachment {\n    uint32_t id; // ID of the attachment\n    uint16_t bone; // bone to attach to\n    uint16_t unknown; // always 0\n    float position[3]; // position of the attachment\n    // M2Track<uint8_t> data; // animated attachment data\n};\n```",
        "constants_and_flags": "CreatureModelData.dbc Flags:\n0x00001 = No Footprint Particles\n0x00002 = No Breath Particles\n0x00004 = Is Player Model\n0x00008 = No Attached Weapons\n0x00010 = No Footprint Trail Textures\n0x00020 = Disable Highlight\n0x00040 = Can Mount while Transformed as this\n0x00080 = Disable Scale Interpolation\n0x00100 = Force Projected Tex. (EXPENSIVE)\n0x00200 = Can Jump In Place As Mount\n0x00400 = AI cannot use walk backwards anim\n0x00800 = Ignore SpineLow for SplitBody\n0x01000 = Ignore Head for SplitBody\n0x02000 = Ignore SpineLow for SplitBody when Flying\n0x04000 = Ignore Head for SplitBody when Flying\n0x08000 = Use 'wheel' animation on unit wheel bones\n0x10000 = Is HD Model\n0x20000 = Suppress Emitters on Low Settings",
        "relationships": "- `CreatureDisplayInfo.dbc` links to `CreatureModelData.dbc` to specify the model for a given display ID.\n- `CreatureModelData.dbc` and `CreatureDisplayInfo.dbc` link to `CreatureSoundData.dbc` for sound information.\n- `CreatureModelData.dbc` links to `UnitBloodLevels.dbc` and `FootprintTextures.dbc`.\n- `CreatureDisplayInfo.dbc` links to `CreatureDisplayInfoExtra.dbc`, `UnitBlood.dbc`, `NPCSounds.dbc`, `ParticleColor.dbc`, and `ObjectEffectPackage.dbc`.\n- The M2 model format contains attachment points which are used to position riders on mounts.",
        "tools": "MyDBCEditor: A tool for editing DBC files.\n010 Editor: A hex editor with templates for various file formats, including M2 models.\nWoW Model Viewer (WMV): A tool for viewing and exporting WoW models.",
        "code_examples": "```c\nstruct CreatureModelDataRec {\n  uint32_t m_ID;\n  uint32_t m_flags;\n  char* m_ModelName;\n  uint32_t m_sizeClass;\n  float m_modelScale;\n  uint32_t m_bloodID;\n  uint32_t m_footprintTextureID;\n  float m_footprintTextureLength;\n  float m_footprintTextureWidth;\n  float m_footprintParticleScale;\n  uint32_t m_foleyMaterialID;\n  uint32_t m_footstepShakeSize;\n  uint32_t m_deathThudShakeSize;\n  uint32_t m_soundID;\n  float m_collisionWidth;\n  float m_collisionHeight;\n  float m_mountHeight;\n  float m_geoBoxMin[3];\n  float m_geoBoxMax[3];\n  float m_worldEffectScale;\n  float m_attachedEffectScale;\n  float m_missileCollisionRadius;\n  float m_missileCollisionPush;\n  float m_missileCollisionRaise;\n};\n```\n\n```c\nstruct CreatureDisplayInfoRec {\n  uint32_t m_ID;\n  uint32_t m_modelID;\n  uint32_t m_soundID;\n  uint32_t m_extendedDisplayInfoID;\n  float m_creatureModelScale;\n  uint32_t m_creatureModelAlpha;\n  char* m_textureVariation[3];\n  uint32_t m_sizeClass;\n  uint32_t m_bloodID;\n  uint32_t m_NPCSoundID;\n};\n```\n\n```c\nstruct M2Attachment {\n    uint32_t id;\n    uint16_t bone;\n    uint16_t unknown;\n    float position[3];\n    // M2Track<uint8_t> data; // animated attachment data\n};\n```",
        "sources": "https://wowdev.wiki/DB/CreatureModelData\nhttps://wowdev.wiki/DB/CreatureDisplayInfo\nhttps://wowdev.wiki/M2",
        "detailed_findings": "/home/ubuntu/detailed_findings/10_cb4AfVIyjN2Cxsqo6PJmaJ_1769897247235_na1fn_L2hvbWUvdWJ1bnR1L2RldGFpbGVkX2ZpbmRpbmdz.md"
      },
      "error": ""
    },
    {
      "input": "Item Display System - Research item rendering including: ItemDisplayInfo DBC, helmet/shoulder geosets, weapon attachment points, item visual effects, enchant visuals, how items modify character models",
      "output": {
        "topic": "Item Display System",
        "summary": "The Item Display System in World of Warcraft 3.3.5a is a complex and data-driven system responsible for rendering items on characters and in the game world. It relies on a combination of DBC files, primarily ItemDisplayInfo.dbc, and model data in M2 and .skin formats to control everything from an item's appearance and icon to its visual effects and how it modifies a character's geometry. This system uses geosets to dynamically alter character models based on equipped armor, with a hardcoded priority system to resolve conflicts between different items. Weapon effects and enchantments are handled through a system of attachment points on the M2 models, linked to visual effect definitions in other DBC files.",
        "struct_definitions": "```c\nstruct ItemDisplayInfoRec {\n  uint32_t  m_ID;\n  char*     m_leftModelPath;\n  char*     m_rightModelPath;\n  char*     m_leftModelTexturePath;\n  char*     m_rightModelTexturePath;\n  char*     m_icon1;\n  char*     m_icon2;\n  uint32_t  m_geosetGroup[3];\n  uint32_t  m_flags; // &1: EmblazonedTabard, &2: hides underwear, &4: event specific\n  uint32_t  m_spellVisualID;\n  uint32_t  m_groupSoundIndex; // foreign key to ItemGroupSounds.dbc\n  uint32_t  m_helmetGeosetVisMale; // foreign key to HelmetGeosetVisData.dbc\n  uint32_t  m_helmetGeosetVisFemale; // foreign key to HelmetGeosetVisData.dbc\n  char*     m_upperArmTexture;\n  char*     m_lowerArmTexture;\n  char*     m_handsTexture;\n  char*     m_upperTorsoTexture;\n  char*     m_lowerTorsoTexture;\n  char*     m_upperLegTexture;\n  char*     m_lowerLegTexture;\n  char*     m_footTexture;\n  uint32_t  m_itemVisual; // foreign key to ItemVisuals.dbc\n  uint32_t  m_particleColorID; // foreign key to ParticleColor.dbc\n};\n\nstruct M2SkinProfile {\n  uint32_t                magic;         // 'SKIN'\n  M2Array<unsigned short> vertices;\n  M2Array<unsigned short> indices;\n  M2Array<ubyte4>         bones;\n  M2Array<M2SkinSection>  submeshes;\n  M2Array<M2Batch>        batches;\n  uint32_t                boneCountMax;\n  M2Array<M2ShadowBatch>  shadow_batches;\n};\n```",
        "constants_and_flags": "ItemDisplayInfo.dbc Flags:\nEmblazonedTabard = 0x1\nhides_underwear = 0x2\nevent_specific = 0x4\n\nGeoset Groups:\nHead_geosetGroup_0 = 2700\nHead_geosetGroup_1 = 2101\nShoulder_geosetGroup_0 = 2601\nShirt_geosetGroup_0 = 801\nShirt_geosetGroup_1 = 1001\nChest_geosetGroup_0 = 801\nChest_geosetGroup_1 = 1001\nChest_geosetGroup_2 = 1301\nChest_geosetGroup_3 = 2201\nChest_geosetGroup_4 = 2801\nWaist_geosetGroup_0 = 1801\nPants_geosetGroup_0 = 1101\nPants_geosetGroup_1 = 901\nPants_geosetGroup_2 = 1301\nBoots_geosetGroup_0 = 501\nBoots_geosetGroup_1 = 2000\nGloves_geosetGroup_0 = 401\nGloves_geosetGroup_1 = 2301\nCape_geosetGroup_0 = 1501\nTabard_geosetGroup_0 = 1201",
        "relationships": "- ItemDisplayInfo.dbc is the central file, linking to models, textures, and other DBC files.\n- M2 files define the 3D models for items, including their geometry, animations, and attachment points.\n- .skin files define the different levels of detail (LODs) for a model and how textures are applied.\n- ItemVisuals.dbc links visual effects to the attachment points on a weapon model.\n- ItemVisualEffects.dbc defines the models used for visual effects.\n- SpellVisual.dbc defines the visual appearance of spells and some enchantment effects.\n- HelmetGeosetVisData.dbc controls the visibility of helmet geosets.\n- ItemGroupSounds.dbc defines the sounds that items make.\n- ParticleColor.dbc defines the colors of particles used in visual effects.",
        "tools": "DBC Editor: For viewing and editing DBC files like ItemDisplayInfo.dbc.\nWoW Model Viewer: For viewing M2 models and their animations.\nM2/Skin file editors: For modifying the 3D models and their textures.",
        "code_examples": "```c\n// Pseudocode for geoset priority\nfunction resolve_geosets(gloves, chest, shirt, belt, tabard, pants, boots) {\n  // Sleeve geoset\n  if (gloves.geosetGroup[0] != 0) {\n    apply_geoset(gloves.geosetGroup[0]);\n  } else if (chest.geosetGroup[0] != 0) {\n    apply_geoset(chest.geosetGroup[0]);\n  } else {\n    apply_geoset(shirt.geosetGroup[0]);\n  }\n\n  // Belt/Tabard geoset\n  if (belt.geosetGroup[0] != 0) {\n    apply_geoset(belt.geosetGroup[0]);\n  } else {\n    apply_geoset(tabard.geosetGroup[0]);\n  }\n\n  // Robe/Pants/Boots geoset\n  if (chest.geosetGroup[2] != 0) {\n    apply_geoset(chest.geosetGroup[2]);\n  } else if (pants.geosetGroup[2] != 0) {\n    apply_geoset(pants.geosetGroup[2]);\n  } else if (boots.geosetGroup[0] != 0) {\n    apply_geoset(boots.geosetGroup[0]);\n  } else {\n    apply_geoset(pants.geosetGroup[1]);\n  }\n}\n```",
        "sources": "https://wowdev.wiki/DB/ItemDisplayInfo\nhttps://wowdev.wiki/M2\nhttps://wowdev.wiki/M2/.skin",
        "detailed_findings": "/home/ubuntu/detailed_findings/11_KaHiM2yX8UnkMbj8F8wTqz_1769897305140_na1fn_L2hvbWUvdWJ1bnR1L2ZpbmFsX3JlcG9ydA.md"
      },
      "error": ""
    },
    {
      "input": "Navigation and Pathfinding - Research server-side navigation including: vmaps (visibility maps), mmaps (movement maps), height maps, line of sight calculation, pathfinding algorithms used",
      "output": {
        "topic": "WoW 3.3.5a Server-Side Navigation and Pathfinding",
        "summary": "Server-side navigation in World of Warcraft 3.3.5a is a complex system that relies on a combination of data structures to enable realistic NPC movement. The system uses MAPs for basic terrain data, VMAPs for line of sight and collision, and MMAPs to generate navigation meshes for pathfinding. The pathfinding itself is powered by the Recast and Detour libraries, which use the A* algorithm to find optimal paths on the generated navmeshes.",
        "struct_definitions": "No specific C-style struct definitions were found in the researched documentation. The information available describes the general data structures and file formats at a high level.",
        "constants_and_flags": "No specific constants or flags were found during the research.",
        "relationships": "*   VMAPs and MMAPs are generated from the base MAP data (ADT/WDT files).\n*   WMO and M2 models are used in VMAP generation for collision.\n*   The pathfinding system is used by the server's AI to control NPC movement.",
        "tools": "mapextractor.exe: Extracts map data from the game's MPQ files.\nvmap4extractor.exe: Extracts VMAP data.\nvmap4assembler.exe: Assembles the extracted VMAP data.\nmmaps_generator.exe: Generates MMAPs from the extracted map and VMAP data.\nRecast Debug: A tool for visualizing and debugging the generated navmeshes.",
        "code_examples": "```cpp\n// Pseudocode for pathfinding with Recast/Detour\n\n// 1. Load navmesh\ndtNavMesh* navMesh = loadNavMesh(\"path/to/navmesh.mmap\");\n\n// 2. Create navmesh query\ndtNavMeshQuery* navQuery = new dtNavMeshQuery();\nnavQuery->init(navMesh, 2048);\n\n// 3. Define start and end points\nfloat startPos[3] = {x1, y1, z1};\nfloat endPos[3] = {x2, y2, z2};\n\n// 4. Find path\ndtQueryFilter filter;\ndtPolyRef startRef, endRef;\nfloat nearestPt[3];\nnavQuery->findNearestPoly(startPos, extents, &filter, &startRef, nearestPt);\nnavQuery->findNearestPoly(endPos, extents, &filter, &endRef, nearestPt);\n\ndtPolyRef path[MAX_PATH_POLYS];\nint pathCount;\nnavQuery->findPath(startRef, endRef, startPos, endPos, &filter, path, &pathCount, MAX_PATH_POLYS);\n```",
        "sources": "https://www.getmangos.eu/forums/topic/10829-what-are-maps-mmaps-and-vmaps-exactly/\nhttps://github.com/stoneharry/mmaps-for-custom-maps\nhttps://drewkestell.us/Article/6/Chapter/20",
        "detailed_findings": "/home/ubuntu/detailed_findings/12_VSXtnd4HpPCLgGE0pZorYy_1769897279876_na1fn_L2hvbWUvdWJ1bnR1L2RldGFpbGVkX2ZpbmRpbmdz.md"
      },
      "error": ""
    },
    {
      "input": "Sound and Music System - Research audio including: SoundEntries DBC, ZoneMusic DBC, ambient sounds, sound kit system, music triggers, audio file formats used (.wav, .mp3, .ogg)",
      "output": {
        "topic": "WoW 3.3.5a Sound and Music System",
        "summary": "This document details the technical aspects of the sound and music system in World of Warcraft patch 3.3.5a. It covers the structure of the `SoundEntries.dbc` and `ZoneMusic.dbc` files, which are central to how the game handles audio. The document also outlines the various sound types, flags, and their relationships, providing a comprehensive overview for developers looking to work with WoW's audio on a technical level.",
        "struct_definitions": "### SoundEntries.dbc\n\n```c\nstruct SoundEntriesRec {\n  uint32_t m_ID;\n  uint32_t m_soundType;\n  stringref m_name;\n  stringref m_File[10];\n  uint32_t m_Freq[10];\n  stringref m_DirectoryBase;\n  float m_volumeFloat;\n  uint32_t m_flags;\n  float m_minDistance;\n  float m_maxDistance;\n  float m_distanceCutoff;\n  uint32_t m_soundEntriesAdvancedID;\n};\n```\n\n### ZoneMusic.dbc\n\n```c\nenum AMBIENCE {\n  AMB_DAY = 0,\n  AMB_NIGHT = 1,\n  NUM_AMBIENCES = 2,\n};\n\nstruct ZoneMusicRec {\n  uint32_t m_ID;\n  stringref m_SetName;\n  uint32_t m_SilenceIntervalMin[NUM_AMBIENCES];\n  uint32_t m_SilenceIntervalMax[NUM_AMBIENCES];\n  foreign_key<uint32_t, &SoundEntriesRec::m_ID> m_Sounds[NUM_AMBIENCES];\n};\n```",
        "constants_and_flags": "### Sound Types\n\n| Value | Meaning |\n| --- | --- |\n| 1 | Spells |\n| 2 | UI |\n| 3 | Footsteps |\n| 4 | Combat Impacts |\n| 6 | Combat Swings |\n| 7 | Greetings |\n| 8 | Casting |\n| 9 | Pick Up/Put Down |\n| 10 | NPC Combat |\n| 12 | Errors |\n| 13 | Birds |\n| 14 | Doodad Sounds |\n| 16 | Death Thud Sounds |\n| 17 | NPC Sounds |\n| 18 | Test/Temporary |\n| 19 | Foley Sounds (NOT EDITABLE) |\n| 20 | Footsteps(Splashes) |\n| 21 | CharacterSplashSounds |\n| 22 | WaterVolume Sounds |\n| 23 | Tradeskill Sounds |\n| 24 | Terrain Emitter Sounds |\n| 25 | Game Object Sounds |\n| 26 | SpellFizzles |\n| 27 | CreatureLoops |\n| 28 | Zone Music Files |\n| 29 | Character Macro Lines |\n| 30 | Cinematic Music |\n| 31 | Cinematic Voice |\n| 50 | Zone Ambience |\n| 52 | Sound Emitters |\n| 53 | Vehicle States |\n\n### SoundInterfaceFlags\n\n```c\nenum SoundInterfaceFlags\n{\n   UNUSED        = 0x0001,\n   NO_DUPLICATES = 0x0020,\n   LOOPING       = 0x0200,\n   VARY_PITCH    = 0x0400,\n   VARY_VOLUME   = 0x0800,\n}\n```",
        "relationships": "*   **ZoneMusic.dbc to SoundEntries.dbc**: The `ZoneMusic.dbc` file links to `SoundEntries.dbc` to determine which music to play in a specific zone. The `m_Sounds` field in `ZoneMusicRec` is a foreign key to the `m_ID` field in `SoundEntriesRec`.\n*   **SoundEntries.dbc to Audio Files**: The `SoundEntries.dbc` file points to the actual audio files (.wav, .mp3) to be played. The `m_DirectoryBase` and `m_File` fields are combined to create the full path to the sound file.",
        "tools": "DBC Editors: Various DBC editors can be used to view and edit the contents of `SoundEntries.dbc` and `ZoneMusic.dbc`.\nMPQ Editors: MPQ editors are necessary to extract the DBC files and other game assets from the game's data archives.",
        "code_examples": "```lua\n/script PlaySoundFile(\"Sound\\\\Creature\\\\AmbassadorHellmaw\\\\Auch_Helmaw_Slay02.wav\")\n```",
        "sources": "https://wowdev.wiki/DB/SoundEntries\nhttps://wowdev.wiki/DB/ZoneMusic\nhttps://github.com/fondlez/wow-sounds",
        "detailed_findings": "/home/ubuntu/detailed_findings/13_FsUQm7nF2Abc1oSonKikTq_1769897289035_na1fn_L2hvbWUvdWJ1bnR1L3Jlc2VhcmNoL2RldGFpbGVkX2ZpbmRpbmdz.md"
      },
      "error": ""
    },
    {
      "input": "WoW Modding Tools - Research existing tools including: Noggit (terrain editor), WoW Model Viewer, MPQ editors (Ladik's), BLP converters, DBC editors, 010 Editor templates, MyDBCEditor",
      "output": {
        "topic": "WoW Modding Tools",
        "summary": "This research provides a technical overview of essential modding tools for World of Warcraft 3.3.5a. It covers the structure of DBC, BLP, and M2 file formats, and details the features of key tools like Noggit, WoW Model Viewer, MPQ editors, BLP converters, DBC editors, and 010 Editor templates. The findings include struct definitions, enums, and relationships between the various tools and formats, offering a foundational resource for developing AI-native applications for WoW 3.3.5a.",
        "struct_definitions": "struct dbc_header\n{\n  uint32_t magic; // always 'WDBC'\n  uint32_t record_count; // records per file\n  uint32_t field_count; // fields per record\n  uint32_t record_size; // sum (sizeof (field_type_i)) | 0 <= i < field_count. field_type_i is NOT defined in the files.\n  uint32_t string_block_size;\n};\n\ntemplate<typename record_type>\nstruct dbc_file\n{\n  dbc_header header;\n  record_type records[header.record_count];\n  char string_block[header.string_block_size];\n};\n\nstruct BLPHeader {\n  uint32_t magic; // 'BLP2'\n  uint32_t formatVersion; // must be 1\n  BLPColorEncoding colorEncoding;\n  uint8_t alphaChannelBitDepth; // 0, 1, 8, 4\n  BLPPixelFormat preferredFormat;\n  mipmap_level_and_flag_type mipmap_level_and_flags;\n  uint32_t width;\n  uint32_t height;\n#define MIPMAP_COUNT 16\n#define PALETTE_SIZE 256\n  uint32_t dataOffsets[MIPMAP_COUNT];\n  uint32_t dataSizes[MIPMAP_COUNT];\n  uint32_t palette[PALETTE_SIZE];\n};\n\nstruct M2Header\n{\n  uint32_t magic;              // \"MD20\"\n  uint32_t version;\n  M2Array<char> name;\n  struct\n  {\n    uint32_t flag_tilt_x : 1;\n    uint32_t flag_tilt_y : 1;\n    uint32_t : 1;\n    uint32_t flag_use_texture_combiner_combos : 1;\n    uint32_t : 1;\n    uint32_t flag_load_phys_data : 1;\n    uint32_t : 1;\n    uint32_t flag_unk_0x80 : 1;\n    uint32_t flag_camera_related : 1;\n    uint32_t flag_new_particle_record : 1;\n    uint32_t flag_unk_0x400 : 1;\n    uint32_t flag_texture_transforms_use_bone_sequences : 1;\n    uint32_t flag_unk_0x1000 : 1;\n    uint32_t ChunkedAnimFiles_0x2000 : 1;\n    uint32_t flag_unk_0x4000 : 1;\n    uint32_t flag_unk_0x8000 : 1;\n    uint32_t flag_unk_0x10000 : 1;\n    uint32_t flag_unk_0x20000 : 1;\n    uint32_t flag_unk_0x40000 : 1;\n    uint32_t flag_unk_0x80000 : 1;\n    uint32_t flag_unk_0x100000 : 1;\n    uint32_t flag_unk_0x200000 : 1;\n    uint32_t flag_unk_0x40000000 : 1;\n  } global_flags;\n  M2Array<M2Loop> global_loops;\n  M2Array<M2Sequence> sequences;\n  M2Array<uint16_t> sequenceIdxHashById;\n  M2Array<M2CompBone> bones;\n  M2Array<uint16_t> boneIndicesById;\n  M2Array<M2Vertex> vertices;\n  uint32_t num_skin_profiles;\n  M2Array<M2Color> colors;\n  M2Array<M2Texture> textures;\n  M2Array<M2TextureWeight> texture_weights;\n  M2Array<M2TextureTransform> texture_transforms;\n  M2Array<uint16_t> textureIndicesById;\n  M2Array<M2Material> materials;\n  M2Array<uint16_t> boneCombos;\n  M2Array<uint16_t> textureCombos;\n  M2Array<uint16_t> textureCoordCombos;\n  M2Array<uint16_t> textureWeightCombos;\n  M2Array<uint16_t> textureTransformCombos;\n  CAaBox bounding_box;\n  float bounding_sphere_radius;\n  CAaBox collision_box;\n  float collision_sphere_radius;\n  M2Array<uint16_t> collisionIndices;\n  M2Array<C3Vector> collisionPositions;\n  M2Array<C3Vector> collisionFaceNormals;\n  M2Array<M2Attachment> attachments;\n  M2Array<uint16_t> attachmentIndicesById;\n  M2Array<M2Event> events;\n  M2Array<M2Light> lights;\n  M2Array<M2Camera> cameras;\n  M2Array<uint16_t> cameraIndicesById;\n  M2Array<M2Ribbon> ribbon_emitters;\n  M2Array<M2Particle> particle_emitters;\n};",
        "constants_and_flags": "BLPColorEncoding:\nCOLOR_JPEG = 0\nCOLOR_PALETTE = 1\nCOLOR_DXT = 2\nCOLOR_ARGB8888 = 3\nCOLOR_ARGB8888_dup = 4\n\nBLPPixelFormat:\nPIXEL_DXT1 = 0\nPIXEL_DXT3 = 1\nPIXEL_ARGB8888 = 2\nPIXEL_ARGB1555 = 3\nPIXEL_ARGB4444 = 4\nPIXEL_RGB565 = 5\nPIXEL_A8 = 6\nPIXEL_DXT5 = 7\nPIXEL_UNSPECIFIED = 8\nPIXEL_ARGB2565 = 9\nPIXEL_BC5 = 11\nNUM_PIXEL_FORMATS = 12\n\nmipmap_level_and_flag_type:\nMIPS_NONE = 0x0\nMIPS_GENERATED = 0x1\nMIPS_HANDMADE = 0x2\nflags_mipmap_mask = 0xF\nflags_unk_0x10 = 0x10",
        "relationships": "- Noggit is a terrain editor that modifies ADT files, which define the terrain geometry, and WDT files, which describe the map.\n- WoW Model Viewer is used to view M2 (models) and WMO (world map objects) files. It relies on the game's MPQ archives to access the necessary files.\n- MPQ editors, like Ladik's MPQ Editor, are used to open and extract files from the game's MPQ archives, which contain all the game assets.\n- BLP converters are used to convert BLP (texture) files to and from other formats like PNG. These textures are used by M2 and WMO models.\n- DBC editors, like WDBX Editor, are used to edit DBC (database client) files, which contain game data for items, spells, NPCs, and more.\n- 010 Editor, with appropriate templates, can be used to parse and edit various WoW file formats, including M2 files.",
        "tools": "Noggit: A terrain editor for World of Warcraft.\nWoW Model Viewer (WMVx): A tool for viewing and capturing model and character animation from World of Warcraft.\nLadik's MPQ Editor: An editor for MPQ archives.\nBLPConverter: A tool to convert BLP files to and from other image formats.\nWDBX Editor: A DBC editor for WotLK and other WoW versions.\n010 Editor: A hex editor with support for binary templates, which can be used to parse various WoW file formats.\nMyDBCEditor: Another DBC editor.",
        "code_examples": "```c\nstruct dbc_header\n{\n  uint32_t magic; // always 'WDBC'\n  uint32_t record_count; // records per file\n  uint32_t field_count; // fields per record\n  uint32_t record_size; // sum (sizeof (field_type_i)) | 0 <= i < field_count. field_type_i is NOT defined in the files.\n  uint32_t string_block_size;\n};\n\ntemplate<typename record_type>\nstruct dbc_file\n{\n  dbc_header header;\n  record_type records[header.record_count];\n  char string_block[header.string_block_size];\n};\n```\n\n```c\nstruct BLPHeader {\n  uint32_t magic; // 'BLP2'\n  uint32_t formatVersion; // must be 1\n  BLPColorEncoding colorEncoding;\n  uint8_t alphaChannelBitDepth; // 0, 1, 8, 4\n  BLPPixelFormat preferredFormat;\n  mipmap_level_and_flag_type mipmap_level_and_flags;\n  uint32_t width;\n  uint32_t height;\n#define MIPMAP_COUNT 16\n#define PALETTE_SIZE 256\n  uint32_t dataOffsets[MIPMAP_COUNT];\n  uint32_t dataSizes[MIPMAP_COUNT];\n  uint32_t palette[PALETTE_SIZE];\n};\n```\n\n```c\nstruct M2Header\n{\n  uint32_t magic;              // \"MD20\"\n  uint32_t version;\n  M2Array<char> name;\n  struct\n  {\n    uint32_t flag_tilt_x : 1;\n    uint32_t flag_tilt_y : 1;\n    uint32_t : 1;\n    uint32_t flag_use_texture_combiner_combos : 1;\n    uint32_t : 1;\n    uint32_t flag_load_phys_data : 1;\n    uint32_t : 1;\n    uint32_t flag_unk_0x80 : 1;\n    uint32_t flag_camera_related : 1;\n    uint32_t flag_new_particle_record : 1;\n    uint32_t flag_unk_0x400 : 1;\n    uint32_t flag_texture_transforms_use_bone_sequences : 1;\n    uint32_t flag_unk_0x1000 : 1;\n    uint32_t ChunkedAnimFiles_0x2000 : 1;\n    uint32_t flag_unk_0x4000 : 1;\n    uint32_t flag_unk_0x8000 : 1;\n    uint32_t flag_unk_0x10000 : 1;\n    uint32_t flag_unk_0x20000 : 1;\n    uint32_t flag_unk_0x40000 : 1;\n    uint32_t flag_unk_0x80000 : 1;\n    uint32_t flag_unk_0x100000 : 1;\n    uint32_t flag_unk_0x200000 : 1;\n    uint32_t flag_unk_0x40000000 : 1;\n  } global_flags;\n  M2Array<M2Loop> global_loops;\n  M2Array<M2Sequence> sequences;\n  M2Array<uint16_t> sequenceIdxHashById;\n  M2Array<M2CompBone> bones;\n  M2Array<uint16_t> boneIndicesById;\n  M2Array<M2Vertex> vertices;\n  uint32_t num_skin_profiles;\n  M2Array<M2Color> colors;\n  M2Array<M2Texture> textures;\n  M2Array<M2TextureWeight> texture_weights;\n  M2Array<M2TextureTransform> texture_transforms;\n  M2Array<uint16_t> textureIndicesById;\n  M2Array<M2Material> materials;\n  M2Array<uint16_t> boneCombos;\n  M2Array<uint16_t> textureCombos;\n  M2Array<uint16_t> textureCoordCombos;\n  M2Array<uint16_t> textureWeightCombos;\n  M2Array<uint16_t> textureTransformCombos;\n  CAaBox bounding_box;\n  float bounding_sphere_radius;\n  CAaBox collision_box;\n  float collision_sphere_radius;\n  M2Array<uint16_t> collisionIndices;\n  M2Array<C3Vector> collisionPositions;\n  M2Array<C3Vector> collisionFaceNormals;\n  M2Array<M2Attachment> attachments;\n  M2Array<uint16_t> attachmentIndicesById;\n  M2Array<M2Event> events;\n  M2Array<M2Light> lights;\n  M2Array<M2Camera> cameras;\n  M2Array<uint16_t> cameraIndicesById;\n  M2Array<M2Ribbon> ribbon_emitters;\n  M2Array<M2Particle> particle_emitters;\n};\n```",
        "sources": "https://github.com/wowdev/noggit3\nhttps://wowdev.wiki/Main_Page\nhttps://wowdev.wiki/DBC\nhttps://github.com/Frostshake/WMVx\nhttp://www.zezula.net/en/mpq/download.html\nhttps://wowdev.wiki/BLP\nhttps://github.com/WowDevTools/WDBXEditor\nhttps://www.sweetscape.com/010editor/repository/templates/\nhttps://www.sweetscape.com/010editor/repository/templates/file_info.php?file=M2.bt&type=0&sort=\nhttps://wowdev.wiki/M2",
        "detailed_findings": "/home/ubuntu/detailed_findings/14_LeZmPLxVyxyZsSDZQ8Nipw_1769897402794_na1fn_L2hvbWUvdWJ1bnR1L3Jlc2VhcmNoX2ZpbmRpbmdz.md"
      },
      "error": ""
    },
    {
      "input": "Client Memory and Offsets - Research WoW 3.3.5a 12340 client including: known memory offsets, object manager structure, player/unit structures, spell casting offsets, commonly used patterns",
      "output": {
        "topic": "Client Memory and Offsets in WoW 3.3.5a",
        "summary": "This research provides a comprehensive overview of the memory layout of the World of Warcraft 3.3.5a client (build 12340). It includes detailed information on memory offsets, the structure of the Object Manager, and various data structures for players, units, and other game objects. The findings are based on information gathered from community forums and open-source projects, providing a solid foundation for developing AI-native applications that interact with the game client.",
        "struct_definitions": "```c\n// Object Fields\nstruct ObjectFields {\n    uint64_t guid;              // 0x00\n    uint32_t type;              // 0x08\n    uint32_t entry;             // 0x0C\n    float    scale_x;           // 0x10\n    uint32_t padding;           // 0x14\n};\n\n// Item Fields\nstruct ItemFields {\n    uint64_t owner;             // 0x18\n    uint64_t contained;         // 0x20\n    uint64_t creator;           // 0x28\n    uint64_t giftcreator;       // 0x30\n    uint32_t stack_count;       // 0x38\n    uint32_t duration;          // 0x3C\n    uint32_t spell_charges[5];  // 0x40\n    uint32_t flags;             // 0x54\n    uint32_t enchantments[12][2]; // 0x58\n    uint32_t property_seed;     // 0xE8\n    uint32_t random_properties_id; // 0xEC\n    uint32_t durability;        // 0xF0\n    uint32_t max_durability;    // 0xF4\n    uint32_t create_played_time; // 0xF8\n    uint32_t pad;               // 0xFC\n};\n\n// Unit Fields\nstruct UnitFields {\n    uint64_t charm;             // 0x18\n    uint64_t summon;            // 0x20\n    uint64_t critter;           // 0x28\n    uint64_t charmed_by;        // 0x30\n    uint64_t summoned_by;       // 0x38\n    uint64_t created_by;        // 0x40\n    uint64_t target;            // 0x48\n    uint64_t channel_object;    // 0x50\n    uint32_t channel_spell;     // 0x58\n    uint32_t bytes_0;           // 0x5C\n    uint32_t health;            // 0x60\n    uint32_t power[7];          // 0x64\n    uint32_t max_health;        // 0x80\n    uint32_t max_power[7];      // 0x84\n    uint32_t level;             // 0xD8\n    // ... and so on\n};\n```",
        "constants_and_flags": "LUA_GETTOP = 0x0084DBD0\nLUA_SETTOP = 0x0084DBF0\nLUA_PUSHSTRING = 0x0084E350\nLUA_PUSHINTEGER = 0x0084E2D0\nLUA_PCALL = 0x0084EC50\nCURMGR_OFFSET = 0x00B41414\nCURMGR_PTR_OFFSET = 0x24\nNEXT_OBJECT_OFFSET = 0x3C\nOBJECT_TYPE_OFFSET = 0x14",
        "relationships": "* The **Object Manager** is the central hub for all in-game objects. It maintains a linked list of objects, which can be traversed to access individual players, units, and game objects.\n*   Each object in the Object Manager has a **GUID** (Globally Unique Identifier) that uniquely identifies it.\n*   Player and unit objects have a **UnitFields** structure that contains detailed information about their stats, such as health, mana, and level.\n*   The client's **Lua engine** can be manipulated to execute scripts and interact with the game world programmatically.",
        "tools": "Cheat Engine: A memory scanner and debugger that can be used to find memory addresses and pointers.\nReClass.NET: A tool for reverse engineering class structures from memory.\nOllyDbg, x64dbg, WinDbg: Various debuggers for analyzing the game client's code and memory.",
        "code_examples": "```python\n# Get Player Object: Read pointer at (WoW.exe + CURMGR_OFFSET), then read pointer at (result + CURMGR_PTR_OFFSET)\n# Iterate Object Manager: Start with first object, then follow NEXT_OBJECT_OFFSET until it's 0 or loops.\n# Get Unit Health: (Unit_Object_Base + UNIT_HEALTH)\n```\n\n```csharp\npublic void Ping()\n{\n    // ... (code to read player data)\n}\n```",
        "sources": "https://www.ownedcore.com/forums/world-of-warcraft/world-of-warcraft-bots-programs/wow-memory-editing/298984-3-3-5a-12340-offsets-3.html\nhttps://github.com/AzDeltaQQ/WotLKRotations\nhttps://wowdev.wiki/ObjectManager\nhttps://www.unknowncheats.me/forum/world-of-warcraft/370439-3-3-5a-adress-offset-dump-question-warmane.html\nhttps://github.com/johnmoore/WoW-Object-Manager",
        "detailed_findings": "/home/ubuntu/detailed_findings/15_nM89OLOEaghTvXk8zaOIjP_1769897378092_na1fn_L2hvbWUvdWJ1bnR1L2RldGFpbGVkX2ZpbmRpbmdz.md"
      },
      "error": ""
    },
    {
      "input": "Lua AddOn API 3.3.5a - Research the complete Lua API including: all global functions, frame types, events, widget methods, secure templates, protected functions, XML schema",
      "output": {
        "topic": "Lua AddOn API 3.3.5a",
        "summary": "The World of Warcraft 3.3.5a Lua AddOn API provides a comprehensive set of functions, events, and widgets for creating custom user interface modifications. The API includes a wide range of global functions for interacting with the game world, a detailed event system for responding to game events, and a flexible widget system for creating UI elements. The API also includes a secure template and protected function system for performing restricted actions in a secure manner.",
        "struct_definitions": "Not applicable to the Lua AddOn API.",
        "constants_and_flags": "ExpansionLevel:\n0 = WoW\n1 = The Burning Crusade\n2 = Wrath of the Lich King\n3 = Cataclysm\n4 = Mists of Pandaria\n5 = Warlords of Draenor\n6 = Legion\n7 = Battle for Azeroth\n8 = Shadowlands",
        "relationships": "* The Lua API is used to create addons that can interact with and modify the World of Warcraft user interface.\n* The XML schema is used to define the structure and layout of UI elements, which can then be manipulated by Lua scripts.\n* Secure Templates and Protected Functions are used to provide a secure way for addons to perform actions that are normally restricted, such as casting spells or using items.",
        "tools": "WoW UI Designer: A visual tool for creating and editing WoW UI XML files.",
        "code_examples": "```xml\n<Ui xmlns=\"http://www.blizzard.com/wow/ui/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.blizzard.com/wow/ui/ ..\\\\FrameXML\\\\UI.xsd\">\n\t<Frame name=\"MyAddonFrame\">  <!-- a sample widget -->\n\t\t<!-- sample properties and children -->\n\t\t<Scripts>   \n\t\t\t<OnLoad function=\"MyAddonFrame_OnLoad\" />\n\t\t</Scripts>\n\t\t<Layers>\n\t\t\t<Layer level=\"ARTWORK\">\n\t\t\t\t<Texture name=\"MyAddonFrameTexture\" />\n\t\t\t</Layer>\n\t\t</Layers>\n\t</Frame>  <!-- end of sample widget -->\n</Ui>\n```",
        "sources": "https://wowwiki-archive.fandom.com/wiki/World_of_Warcraft_API\nhttps://wowwiki-archive.fandom.com/wiki/Events_A-Z_(full_list)\nhttps://wowwiki-archive.fandom.com/wiki/Widget_API\nhttps://wowwiki-archive.fandom.com/wiki/SecureTemplates\nhttps://wowwiki-archive.fandom.com/wiki/Category:World_of_Warcraft_API/Protected_Functions\nhttps://warcraft.wiki.gg/wiki/XML_user_interface",
        "detailed_findings": "/home/ubuntu/detailed_findings/16_6tYvOjHHBAsjrFCPfkSZfh_1769897623703_na1fn_L2hvbWUvdWJ1bnR1L3dvd19hcGlfZmluZGluZ3M.md"
      },
      "error": ""
    },
    {
      "input": "Network Protocol Basics - Research client-server protocol including: packet structure, common opcodes, authentication flow, world packet format, compression",
      "output": {
        "topic": "WoW 3.3.5a Network Protocol Basics",
        "summary": "The World of Warcraft 3.3.5a network protocol is a client-server protocol that uses TCP for communication. It has a distinct authentication flow and world packet format. Packet headers are encrypted using a session key, and the structure of the packets differs between client-to-server and server-to-client communication.",
        "struct_definitions": "/* Server-to-Client Packet Header */\nstruct SMSG_Header {\n    uint16 size; // Big-endian, 2 or 3 bytes depending on a flag\n    uint16 opcode; // Little-endian\n};\n\n/* Client-to-Server Packet Header */\nstruct CMSG_Header {\n    uint16 size; // Big-endian\n    uint32 opcode; // Little-endian\n};\n\n/* Structure to hold context for a WoW network conversation */\nstruct WowwContext {\n    guint expectedSize;     // Expected size of the next packet\n    guint32 lastNum;        // Last frame number\n    guint32 packet_counter; // Number of packets seen in the conversation\n};",
        "constants_and_flags": "WOWW_DEFAULT_PORT = 8085\n\n// A flag in the first byte of the server packet header indicates a 3-byte size\nSMSG_SIZE_3_BYTE_FLAG = 0x80",
        "relationships": "- The client first connects to the authentication server (default port 3724) to authenticate and get a realm list.\n- After selecting a realm, the client disconnects from the authentication server and connects to the world server (default port 8085) for gameplay.\n- The session key negotiated with the authentication server is used to encrypt/decrypt world packets.",
        "tools": "Wireshark: A network protocol analyzer that can be used with a custom dissector to parse WoW packets.\nCheat Engine: Used to extract the RC4 session keys from the game client's memory.",
        "code_examples": "```c\n// Pseudocode for decrypting and parsing a server-to-client packet\n\nfunction parse_server_packet(packet_data) {\n  // The first packet (SMSG_AUTH_CHALLENGE) is not encrypted\n  if (is_first_packet) {\n    header = packet_data.read(4);\n  } else {\n    encrypted_header = packet_data.read(4);\n    decrypted_header = rc4_decrypt(encrypted_header);\n    header = decrypted_header;\n  }\n\n  // Check for 3-byte size encoding\n  if (header[0] & 0x80) {\n    size = ((header[0] & 0x7F) << 16) | (header[1] << 8) | header[2];\n    opcode = (header[3] << 8) | header[4];\n    payload = packet_data.read(size - 2);\n  } else {\n    size = (header[0] << 8) | header[1];\n    opcode = (header[2] << 8) | header[3];\n    payload = packet_data.read(size - 2);\n  }\n\n  return {size, opcode, payload};\n}\n```",
        "sources": "https://wowdev.wiki/World_Packet\nhttps://wowdev.wiki/Login_Packet\nhttps://github.com/chaodhib/Wow-wireshark-dissector",
        "detailed_findings": "/home/ubuntu/detailed_findings/17_CHaNYbMnSXN4nj2TJa79uD_1769897360670_na1fn_L2hvbWUvdWJ1bnR1L3Jlc2VhcmNoX25vdGVz.md"
      },
      "error": ""
    },
    {
      "input": "Procedural Content Generation for WoW - Research existing procedural generation approaches including: terrain generation algorithms, dungeon generation, how to programmatically create valid ADT/WDT files",
      "output": {
        "topic": "Procedural Content Generation for WoW 3.3.5a",
        "summary": "This research provides a detailed analysis of the technical specifications for procedural content generation in World of Warcraft 3.3.5a, focusing on terrain generation through WDT and ADT files. The investigation concludes that there is no evidence of procedural dungeon generation in this version of the game, with dungeons and raids being manually constructed using WMO and ADT files.",
        "struct_definitions": "```c\n// WDT MPHD Chunk\nstruct SMMapHeader {\n   uint32_t flags; // Flags for the map\n   uint32_t something; // Used in WotLK to initialize MAIN chunk data\n   uint32_t unused[6]; // Unused padding\n};\n\n// WDT MAIN Chunk\nstruct SMAreaInfo {\n  uint32_t Flag_HasADT : 1; // Indicates if this tile has an ADT file\n  uint32_t Flag_AllWater : 1; // Indicates if the tile is all water\n  uint32_t Flag_Loaded : 1; // Client-side flag\n  uint32_t asyncId;    // Client-side async ID\n};\n\n// WDT MODF Chunk\nstruct SMMapObjDef {\n  uint nameId; // Unused\n  uint uniqueId; // Unused\n  float pos[3]; // Position of the WMO\n  float rot[3]; // Rotation of the WMO\n  float extents_upper[3]; // Upper corner of the bounding box\n  float extents_lower[3]; // Lower corner of the bounding box\n  uint16 flags; // WMO flags\n  uint16 doodadSet; // Doodad set index\n  uint16 nameSet; // Name set index\n  uint16 pad; // Padding\n};\n\n// ADT MVER Chunk\nstruct MVER {\n  uint32_t version; // File version (18 for 3.3.5a)\n};\n\n// ADT MHDR Chunk\nstruct SMMapHeader {\n  uint32_t flags; // Header flags\n  uint32_t mcin;      // Offset to MCIN chunk\n  uint32_t mtex;      // Offset to MTEX chunk\n  uint32_t mmdx;      // Offset to MMDX chunk\n  uint32_t mmid;      // Offset to MMID chunk\n  uint32_t mwmo;      // Offset to MWMO chunk\n  uint32_t mwid;      // Offset to MWID chunk\n  uint32_t mddf;      // Offset to MDDF chunk\n  uint32_t modf;      // Offset to MODF chunk\n  uint32_t mfbo;      // Offset to MFBO chunk\n  uint32_t mh2o;      // Offset to MH2O chunk\n  uint32_t mtxf;      // Offset to MTXF chunk\n  uint8_t mamp_value; // Added in Cata+\n  uint8_t padding[3]; // Padding\n  uint32_t unused[3]; // Unused padding\n};\n\n// ADT MCIN Chunk\nstruct SMChunkInfo {\n  uint32_t offset;    // Absolute offset to the MCNK chunk\n  uint32_t size;      // Size of the MCNK chunk\n  uint32_t flags;     // Client-side flags\n  uint32_t asyncId;   // Client-side async ID\n} mcin[256];\n\n// ADT MDDF Chunk\nstruct SMDoodadDef {\n    uint32_t nameId;        // Index into the MMID chunk\n    uint32_t uniqueId;      // Unique ID for this doodad\n    float pos[3]; // Position of the doodad\n    float rot[3]; // Rotation of the doodad\n    uint16_t scale; // Scale of the doodad\n    uint16_t flags; // Doodad flags\n};\n\n// ADT MCNK Chunk\nstruct MCNK {\n    uint32_t flags; // Chunk flags\n    uint32_t indexX; // X index of the chunk\n    uint32_t indexY; // Y index of the chunk\n    uint32_t nLayers; // Number of texture layers\n    uint32_t nDoodadRefs; // Number of doodad references\n    uint32_t ofsMCVT;     // Offset to MCVT sub-chunk (height map)\n    uint32_t ofsMCNR;     // Offset to MCNR sub-chunk (normals)\n    uint32_t ofsMCLY;     // Offset to MCLY sub-chunk (texture layers)\n    uint32_t ofsMCRF;     // Offset to MCRF sub-chunk (doodad references)\n    uint32_t ofsMCAL;     // Offset to MCAL sub-chunk (alpha maps)\n    uint32_t sizeAlpha; // Size of the alpha map data\n    uint32_t ofsMCSH;     // Offset to MCSH sub-chunk (shadow map)\n    uint32_t sizeShadow; // Size of the shadow map data\n    uint32_t areaid; // Area ID\n    uint32_t nMapObjRefs; // Number of WMO references\n    uint32_t holes; // Terrain holes bitmask\n    uint16_t ReallyLowQualityTextureingMap[8]; // Low-quality texture map\n    uint32_t predTex; // Predicted texture\n    uint32_t nEffectDoodad; // Number of effect doodads\n    uint32_t ofsMCSE;     // Offset to MCSE sub-chunk (sound emitters)\n    uint32_t nSndEmitters; // Number of sound emitters\n    uint32_t ofsMCLQ;     // Offset to MCLQ sub-chunk (liquid data)\n    uint32_t sizeLiquid; // Size of the liquid data\n    float  zpos; // Z position of the chunk\n    float  xpos; // X position of the chunk\n    float  ypos; // Y position of the chunk\n    uint32_t textureId;   // Texture ID\n    uint32_t props;       // Properties\n    uint32_t effectId;    // Effect ID\n};\n\n// ADT MH2O Chunk\nstruct MH2O_Header {\n    uint32_t ofsInformation; // Offset to information block\n    uint32_t layerCount;     // Number of liquid layers\n    uint32_t ofsData;        // Offset to data block\n};\n\nstruct MH2O_Information {\n    uint16_t liquidType; // Type of liquid\n    uint16_t flags; // Liquid flags\n    float heightLevel1; // First height level\n    float heightLevel2; // Second height level\n    uint8_t xOffset; // X offset of the liquid quad\n    uint8_t yOffset; // Y offset of the liquid quad\n    uint8_t width; // Width of the liquid quad\n    uint8_t height; // Height of the liquid quad\n    uint32_t ofsBitmap; // Offset to existence bitmap\n    uint32_t ofsVertexData; // Offset to vertex data\n};\n```",
        "constants_and_flags": "MPHD Flags:\nwdt_uses_global_map_obj = 0x1\nadt_has_mccv = 0x2\nadt_has_big_alpha = 0x4\nadt_has_doodadrefs_sorted_by_size_cat = 0x8\nFLAG_LIGHTINGVERTICES = 0x10\nadt_has_upside_down_ground = 0x20",
        "relationships": "- WDT files act as a container or index for ADT files, defining the overall map layout.\n- ADT files contain the actual terrain data, including heightmaps, textures, and references to WMOs and M2 models.\n- WMO (World Map Object) files are used for large structures and buildings within the game world, and are placed within ADTs.\n- M2 files are used for smaller models, such as characters, creatures, and doodads, and are also placed within ADTs.",
        "tools": "Noggit: A popular map editor for WotLK that allows for graphical editing of ADT and WDT files.\nAdtTools: A C# framework for programmatically manipulating ADT files.\nwow-adt and wow-wdt: Rust crates for parsing and manipulating ADT and WDT files.\n010 Editor: A hex editor with templates for various WoW file formats, including ADT and WDT.",
        "code_examples": "```c\n// WDT MPHD Chunk\nstruct SMMapHeader {\n   uint32_t flags;\n   uint32_t something;\n   uint32_t unused[6];\n};\n\n// WDT MAIN Chunk\nstruct SMAreaInfo {\n  uint32_t Flag_HasADT : 1;\n  uint32_t Flag_AllWater : 1;\n  uint32_t Flag_Loaded : 1;\n  uint32_t asyncId;\n};\n\n// WDT MODF Chunk\nstruct SMMapObjDef {\n  uint nameId;\n  uint uniqueId;\n  float pos[3];\n  float rot[3];\n  float extents_upper[3];\n  float extents_lower[3];\n  uint16 flags;\n  uint16 doodadSet;\n  uint16 nameSet;\n  uint16 pad;\n};\n\n// ADT MVER Chunk\nstruct MVER {\n  uint32_t version;\n};\n\n// ADT MHDR Chunk\nstruct SMMapHeader {\n  uint32_t flags;\n  uint32_t mcin;\n  uint32_t mtex;\n  uint32_t mmdx;\n  uint32_t mmid;\n  uint32_t mwmo;\n  uint32_t mwid;\n  uint32_t mddf;\n  uint32_t modf;\n  uint32_t mfbo;\n  uint32_t mh2o;\n  uint32_t mtxf;\n  uint8_t mamp_value;\n  uint8_t padding[3];\n  uint32_t unused[3];\n};\n\n// ADT MCIN Chunk\nstruct SMChunkInfo {\n  uint32_t offset;\n  uint32_t size;\n  uint32_t flags;\n  uint32_t asyncId;\n} mcin[256];\n\n// ADT MDDF Chunk\nstruct SMDoodadDef {\n    uint32_t nameId;\n    uint32_t uniqueId;\n    float pos[3];\n    float rot[3];\n    uint16_t scale;\n    uint16_t flags;\n};\n\n// ADT MODF Chunk\nstruct SMMapObjDef {\n    uint32_t nameId;\n    uint32_t uniqueId;\n    float pos[3];\n    float rot[3];\n    float extents_upper[3];\n    float extents_lower[3];\n    uint16_t flags;\n    uint16_t doodadSet;\n    uint16_t nameSet;\n    uint16_t pad;\n};\n\n// ADT MCNK Chunk\nstruct MCNK {\n    uint32_t flags;\n    uint32_t indexX;\n    uint32_t indexY;\n    uint32_t nLayers;\n    uint32_t nDoodadRefs;\n    uint32_t ofsMCVT;\n    uint32_t ofsMCNR;\n    uint32_t ofsMCLY;\n    uint32_t ofsMCRF;\n    uint32_t ofsMCAL;\n    uint32_t sizeAlpha;\n    uint32_t ofsMCSH;\n    uint32_t sizeShadow;\n    uint32_t areaid;\n    uint32_t nMapObjRefs;\n    uint32_t holes;\n    uint16_t ReallyLowQualityTextureingMap[8];\n    uint32_t predTex;\n    uint32_t nEffectDoodad;\n    uint32_t ofsMCSE;\n    uint32_t nSndEmitters;\n    uint32_t ofsMCLQ;\n    uint32_t sizeLiquid;\n    float  zpos;\n    float  xpos;\n    float  ypos;\n    uint32_t textureId;\n    uint32_t props;\n    uint32_t effectId;\n};\n\n// ADT MH2O Chunk\nstruct MH2O_Header {\n    uint32_t ofsInformation;\n    uint32_t layerCount;\n    uint32_t ofsData;\n};\n\nstruct MH2O_Information {\n    uint16_t liquidType;\n    uint16_t flags;\n    float heightLevel1;\n    float heightLevel2;\n    uint8_t xOffset;\n    uint8_t yOffset;\n    uint8_t width;\n    uint8_t height;\n    uint32_t ofsBitmap;\n    uint32_t ofsVertexData;\n};\n```",
        "sources": "https://wowdev.wiki/WDT\nhttps://wowdev.wiki/ADT/v18\nhttps://www.wowhead.com/wotlk/forums/topic/random-dungeon-generator-164679",
        "detailed_findings": "/home/ubuntu/detailed_findings/18_b6yaF1k7zh1TVwMLDWpbKz_1769897341534_na1fn_L2hvbWUvdWJ1bnR1L2RldGFpbGVkX2ZpbmRpbmdz.md"
      },
      "error": ""
    },
    {
      "input": "DB2 and WDB Cache Formats - Research extended database formats including: DB2 header structure, WDB cache files, differences from DBC, client cache system",
      "output": {
        "topic": "DB2 and WDB Cache Formats",
        "summary": "This research covers the technical specifications of DB2 and WDB file formats in World of Warcraft, focusing on version 3.3.5a. DB2 files, which succeeded the DBC format, are detailed with their header structure, although they are more prevalent in post-WotLK clients. WDB files, used for caching server data, are described with their 24-byte header structure for version 3.3.5a, along with various file signatures.",
        "struct_definitions": "```c\nstruct db2_header\n{\n  uint32_t magic;                                               // 'WDB2'\n  uint32_t record_count;\n  uint32_t field_count;                                         // array fields count as the size of array for WDB2\n  uint32_t record_size;\n  uint32_t string_table_size;                                   // string block almost always contains at least one zero-byte\n  uint32_t table_hash;\n  uint32_t build;\n  uint32_t timestamp_last_written;                              // set to time(0); when writing in WowClientDB2_Base::Save()\n  uint32_t min_id;\n  uint32_t max_id;\n  uint32_t locale;                                              // as seen in TextWowEnum\n  uint32_t copy_table_size;                                     // always zero in WDB2 (?) - see WDB3 for information on how to parse this\n};\n```\n\n```c\nstruct wdb_header_335a\n{\n  char      signature[4];      // Identifier for the WDB file type (e.g., 'WMOB', 'WGOB')\n  uint32_t  client_version;    // Client build version\n  char      client_locale[4];  // Client locale (e.g., 'enUS')\n  uint32_t  record_size;       // Size of each record in the file\n  uint32_t  record_version;    // A manually updated versioning field\n  uint32_t  cache_version;     // A packet based versioning field set via SMSG_CLIENTCACHE_VERSION\n};\n```",
        "constants_and_flags": "WDB File Signatures:\nCreatureCache.wdb = WMOB\nGameObjectCache.wdb = WGOB\nItemCache.wdb = WIDB\nItemNameCache.wdb = WNDB\nItemTextCache.wdb = WITX\nNPCCache.wdb = WNPC\nPageTextCache.wdb = WPTX\nQuestCache.wdb = WQST",
        "relationships": "- DB2 is the successor to the DBC file format, used for client-side databases.\n- WDB files are client-side caches of data sent from the server, which helps to reduce network traffic.\n- Both DB2 and WDB files have a header structure followed by data records.",
        "tools": "WDBX Editor: A DBC/DB2/Cache editor designed to work for all client versions.",
        "code_examples": "```c\nstruct db2_header\n{\n  uint32_t magic;                                               // 'WDB2'\n  uint32_t record_count;\n  uint32_t field_count;                                         // array fields count as the size of array for WDB2\n  uint32_t record_size;\n  uint32_t string_table_size;                                   // string block almost always contains at least one zero-byte\n  uint32_t table_hash;\n  uint32_t build;\n  uint32_t timestamp_last_written;                              // set to time(0); when writing in WowClientDB2_Base::Save()\n  uint32_t min_id;\n  uint32_t max_id;\n  uint32_t locale;                                              // as seen in TextWowEnum\n  uint32_t copy_table_size;                                     // always zero in WDB2 (?) - see WDB3 for information on how to parse this\n};\n```\n\n```c\nstruct wdb_header_335a\n{\n  char      signature[4];      // Identifier for the WDB file type (e.g., 'WMOB', 'WGOB')\n  uint32_t  client_version;    // Client build version\n  char      client_locale[4];  // Client locale (e.g., 'enUS')\n  uint32_t  record_size;       // Size of each record in the file\n  uint32_t  record_version;    // A manually updated versioning field\n  uint32_t  cache_version;     // A packet based versioning field set via SMSG_CLIENTCACHE_VERSION\n};\n```",
        "sources": "https://wowdev.wiki/DB2\nhttps://wowdev.wiki/WDB",
        "detailed_findings": "/home/ubuntu/detailed_findings/19_CcDmutKr0kSpGpFhPslj8N_1769897179248_na1fn_L2hvbWUvdWJ1bnR1L2RldGFpbGVkX2ZpbmRpbmdz.md"
      },
      "error": ""
    }
  ]
}